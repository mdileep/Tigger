/*              syscall.c - System call handler

           (c) Copyright 1990, Charles E. Kindel, Jr. and Sandra Smith
*/
/*--------------------- Start of Declarations ----------------------*/


#include "typedefs2.h"
#include "mbox.h"
#include "term.h"

typedef int (*PFI) () ;

int sem_cond_rec = 1 ;   /* semaphore to give mutual exclusion on
                            the conditional receive */
int spawn = 1 ;          /* semaphore to give mutual exculsion in
                            the spawn routine */ 
int delay = 1 ;         
int Mutex = 1 ;
int sem_terminate = 1 ;

PFI nNewProcess ;

extern int Err ;

extern int startup_pid ;

extern QNODE User_proc ;
extern DNODE Delayed_proc ;
extern QNODE Mail ;

extern MBPTR Disk_req ;


/* - Syscall Handler Routine ---------------------------------------*/
/*
 *   void syscall_handler ( int type, int unit )
 *
 *   PURPOSE:  To handle interrupts generated by syscall.
 *
 *   USAGE:   This routine is called by the interrupt handler. 
 *            int type is not used.
 *            sysargs * sa points to the sysarg data structure.
 *
 */
void syscall_handler (int type, int unit)
{
   TNODEPTR tn ;
   TNODEPTR tmp ;
   QNODEPTR qn ;
   DISKPTR  req ;
   char status [50] ;
   int max_track = disk_ncylinders () ;
   int max_sector = 16 ;

   sysargs *sa = (sysargs*) unit ;

   switch (sa->number)
   {
       case READTERM:
          /* Read a line from a terminal.  Requesting process is */
          /* suspended untile line is read.  Data read is placed in */
          /* memory of the process executing the call. */
          /* arg1 = address of user's line buffer */
          /* arg2 = max size of that buffer */
          /* arg3 = unit number of the terminal */
          /* return in arg2 the number of characters read */
          sa->arg2 = ReadTerm ((char *) sa->arg1, sa->arg2, sa->arg3) ;
          break ;

       case WRITETERM:
          /* Write a line to a terminal. */
          /* arg1 = address of user's line buffer */
          /* arg2 = # of chars to write */
          /* arg3 = unit number of the terminal */
          /* return in arg2 the number of characters actually written */
          sa->arg2 = WriteTerm ((char *) sa->arg1, sa->arg2, sa->arg3) ;
          break ;

       case SPAWN:
          /* Create a process.  Acts much like fork. */
          /* arg1 = address of the funciton to spawn */
          /* arg2 = stack size (in bytes) */
          /* arg3 = priority */
          sa->arg1 = OurSpawn (sa->arg1, sa->arg2, sa->arg3) ;
          break ;
 
       case CREATEMB:
          /* Creates a mailbox */
          /* arg1 = number of slots */
          /* arg2 = size of each slot (in bytes) */
          /* return in arg1 the name of the mailbox.  This name is used later */
          /* in sends and recieves.  If a mailbox cannont be created then name */
          /* is a -1 */
          sa->arg1 = OurCreateMB ( sa->arg1, sa->arg2 ) ;
          qn = (QNODEPTR) malloc (sizeof(QNODE)) ;
          qn->key = sa->arg1 ;          
          ordinsqu (&Mail, qn) ;
          break ;

       case SEND:
          /* Send a message to a mailbox.  Send blocks the calling process until */
          /* the message has been placed in the mail box buffers */
          /* arg1 = mailbox name */
          /* arg2 = pointer to the message to be sent */
          if ( qn = (QNODEPTR) ordremqu (&Mail, sa->arg1) )
          {
             ordinsqu (&Mail, qn) ;
             if (!mbSend ((MBPTR) sa->arg1, (MSGPTR) sa->arg2))       
                terminate () ; 
          }
          else
	  {
	      tprint ("Error Sending to mailbox (%d). Terminating process.\n", sa->arg1) ;
              terminate () ;
	  }
          break ;

       case RECEIVE:
           /* Recieve a message from a mailbox */
           /* arg1 = mailbox name */
           /* arg2 = pointer to a buffer in which to place the recieved message */ 
          if ( qn = (QNODEPTR) ordremqu (&Mail, sa->arg1) )
          {
             ordinsqu (&Mail, qn) ;
             mbReceive ((MBPTR) sa->arg1, (MSGPTR) sa->arg2) ;
          }
          else
	  {
	      tprint ("Error Recieving from mailbox (%d).  Terminating process.\n", sa->arg1) ;
              terminate () ;
	  }
          break ;
  
       case CONDREC:
           /* Conditionally receive a message from a mailbox */
           /* arg1 = mailbox name */
           /* arg2 = pointer to a buffer in which to place the recieved message */
           /* returns in arg1 a boolean value indicating whether the messsage */
           /* was recieved or not */
           P(&sem_cond_rec) ;
           if ( qn = (QNODEPTR) ordremqu (&Mail, sa->arg1) )
           {
              ordinsqu (&Mail, qn) ;
              sa->arg1 = mbCondReceive ((MBPTR) sa->arg1, (MSGPTR) sa->arg2) ;
           }
           else
              sa->arg1 = FALSE ;
           V(&sem_cond_rec) ;
           break ;
 
       case DELAY:
           /* Delay for a specified period of time */
           /* arg1 = number of seconds to delay the calling process */
	   OurDelay (sa->arg1) ;
           break ; 
  
       case DISKPUT:
            /* DISKPUT and DISKGET are provided to perform synchronous I/O on the */
            /* DISK device.  i.e. the caller may not proceed until the disk transfer */
            /* being requested has been completed.  */
            /* arg1 = the memory address from (to) which to transfer */
            /* arg2 = the disk track # */
            /* arg3 = the disk sector # */
            /* return in arg1 a completion code */
            if ( (sa->arg2 >= 0) && (sa->arg2 <= max_track) &&
               (sa->arg3 >= 0) && (sa->arg3 <= max_sector) )
            {
                 req = (DISKPTR) malloc (sizeof(DISKNODE)) ;
		 req->opr = WRITE ; 
		 req->key = sa->arg2 ;
		 req->addr = sa->arg1 ;
		 req->sector = sa->arg3 ;
		 tmp = (TNODEPTR) ordremqu (&User_proc, get_pid() ) ;
		 ordinsqu (&User_proc, (QNODEPTR) tmp ) ;
		 req->mbox = tmp->dbox ;
		 mbSend (Disk_req, (MSGPTR) req) ;
		 mbReceive (req->mbox, (MSGPTR) status) ;
		 sa->arg1 = (int) *status ; 
	    }
	    else
            {
                tprint ("Error Writing to disk.  Terminating process.\n") ;
       	        terminate () ;
            }
          break ;

       case DISKGET:
          if ( (sa->arg2 >= 0) && (sa->arg2 <= max_track) &&
               (sa->arg3 >= 0) && (sa->arg3 <= max_sector) )
          {
             req = (DISKPTR) malloc (sizeof(DISKNODE)) ;
             req->opr = READ ; 
             req->key = sa->arg2 ;
             req->addr = sa->arg1 ;
             req->sector = sa->arg3 ;
             tmp = (TNODEPTR) ordremqu (&User_proc, get_pid() ) ;
             ordinsqu (&User_proc, (QNODEPTR) tmp ) ;
             req->mbox = tmp->dbox ;
             mbSend (Disk_req, (MSGPTR) req) ;
             mbReceive (req->mbox, &status) ;
             sa->arg1 = (int) status ;
          }
          else
          {
              tprint ("Error Reading from disk.  Terminating process.\n") ;
              terminate () ; 
          }
          break ;

       case GETTIMEOFDAY:
          /* Returns the value of the time-of-day clock (i.e. sys_clock()) */
          /* in arg1 */
          sa->arg1 = sys_clock() / 1000L ;
          break ;

       case TERMINATE:
          /* Terminates the invoking process and all of it's children. */
          /* Also releases the resources associated with mailboxes created */
          /* by the process being terminated.  */
          /* When all processes have terminaed OS/0 should shut down. */
          terminate () ; 
          break ;

       default:
          Err = ER_SYSCALL ;                                
          halt () ;
    }
}
/* end of syscall_handler */

/*-------------------------------------------------------
 * int OurCreateMB (numslots, size) 
 *
 *   Creates a mail box using routines in mbox.c
 *
 *   Can be called from syscall handler or from one of
 *   our other internal support routines to avoid 
 *   having to do a syscall.
*/
int OurCreateMB (int numslots, int size) 
{
    int temp ;
    TNODEPTR tmp ;
    QNODEPTR qn ;

          if (-1 == (temp = (int) mbCreate (numslots, size))) 
          {  
	     tprint ("Error creating mailbox.  Terminating process.\n") ;
             terminate () ;
          }
          else
             Update_Process_Mbox( get_pid(), temp );
    return temp ;
}

/*------------------------------------------------------
 * int OurSpawn (add, size, pri) 
 *
 *    Spawns a new process.
 *
 *    Can be called from syscall_handler or from an
 *    internal support routine to avoid having to make
 *    a syscall.
*/
int OurSpawn (int addr, int size, int pri)
{
    int temp ;

          if ((pri >= MIN_PRIORITY - 2 && pri <= MIN_PRIORITY) || startup_pid == get_pid ())
          {
              P (&Mutex)  ;
              P (&spawn) ; 
              nNewProcess = (PFI) addr ;
              temp = fork (&ts2XXp1, size, pri)  ;
              Create_New_Process ( get_pid(), temp ) ;
              if ( get_pid() != startup_pid && 
                   !Update_Parent_Process (get_pid(), temp, 1) ) 
              {
                     tprint ("Error Spawing, could not update parent.  Terminating process.\n") ;
                     terminate () ;
              }
          }
          else
          {   
              tprint ("Error Spawning, invalid priority.  Terminating process.\n") ;
              terminate () ;    /* nuke him if he is bad */
          }

    return temp ;
}

/*----------------------------------
 * void OurDelay (time)
 *
 *   Delays current process for time seconds.
 *   (Approx)
*/
void OurDelay (int time)
{
  DNODEPTR temp ;
  MBPTR    mbox ;
  TNODEPTR the_proc ;
  char buffer [50] ;
  
  temp = (DNODEPTR) malloc (sizeof (DNODE)) ;
  temp->key = time * 50 ;
  /* get currents dbox name  and put in into temp */
  P (&delay) ;
  the_proc = (TNODEPTR) ordremqu (&User_proc, get_pid()) ;
  temp->mbox = the_proc->dbox ;
  ordinsqu (&User_proc, (QNODEPTR) the_proc) ;
  ordinsqu ((QNODEPTR) &Delayed_proc, (QNODEPTR) temp) ;
  V (&delay) ; 
  mbReceive (temp->mbox, buffer) ;
}







