// WOSA/XRT XRTFrame Sample Application Version 1.01
//
// Copyright (c) 1993-94 Microsoft Corporation, All Rights Reserved.
//
//      This is a part of the Microsoft Source Code Samples. 
//      This source code is only intended as a supplement to 
//      Microsoft Development Tools and/or WinHelp documentation.
//      See these sources for detailed information regarding the 
//      Microsoft samples programs.
//
// doc.cpp : implementation of the CDataObject class
//
// CDataObject implementation  
//
// The CDataObject class is derived from MFC's COleServerDoc.  This was done
// to simplify the management of multiple DataObject instances and to
// leverage MFC 2.5's OLE 2.0 support.   A CDataObject, can thus be
// imbedded, linked, etc... with only minimal work.   
//
// This also gives us the ability to store our DataObjects in persistent
// storage for free.  This way, the 'setup' of a DataObject can be stored
// in a file, and from VBA the following code would build the request list:
//
//      Dim xrtobj As Object
//      Set xrtobj = GetObject("C:\STOCKS\PRTFOLIO.XRF")
//
// where the .XRF extension is associated with the XRTFrame sample
// object type and PRTFOLIO.XRF was a previously saved XRTFrame document.
//
// The format of the XRF archive is:
//
//      General "Document" type informaiton
//      - Font
//      - % size of CDataObjectView window (e.g. position of splitter)
//      - CDataObjectView state information
//          - Column widths
//      - CDataView state information
//          - Column widths
//      DataObject settings
//      - UpdateFrequency
//      - MostRecentOnly flag
//      - ColumnDelimiter character
//      - Active flag
//      List of Properties
//      List of Requests
//
// Note that the "DataItems" are not saved to persistent store.
//
// Revisions:
//  December 8, 1993   cek     First implementation.
//  Sept. 29 1994       cek     Updated to the 1.01 specifcation.
//

#include "stdafx.h" 
#include "windowsx.h"
#include "wosaxrt.h"

#if !defined(XRT_VER) || XRT_VER < 0x0101
#pragma message ("ERROR! Requires WOSAXRT.H Version 1.01 (XRT_VER >= 0x0101)")
#endif 

#include "xrtframe.h"
#include "mainfrm.h"
#include "collist.h"

#include "doc.h"
#include "srvritem.h"

#include "request.h"
#include "requests.h"

#include "property.h"
#include "properti.h"

#include "simobj.h"
#include "dataitem.h"
#include "dataitms.h"

#include "view.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDataObject
BEGIN_MESSAGE_MAP(CDataObject, COleServerDoc)
    //{{AFX_MSG_MAP(CDataObject)
    ON_COMMAND(ID_OPTIONS_ACTIVE, OnOptionsActive)
    ON_UPDATE_COMMAND_UI(ID_OPTIONS_ACTIVE, OnUpdateOptionsActive)
    ON_COMMAND(ID_EDIT_COPYALL, OnEditCopyAll)
    ON_UPDATE_COMMAND_UI(ID_EDIT_COPYALL, OnUpdateEditCopyAll)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// CDataObject's IDispatch map
//
// See the MFC 2.5 documentation for details of the macros used here.  Every-
// thing between the //{{AFX... entries were generated by ClassWizard.
//
BEGIN_DISPATCH_MAP(CDataObject, COleServerDoc)
    //{{AFX_DISPATCH_MAP(CDataObject)
    DISP_PROPERTY(CDataObject, "ColumnDelimiter", m_ColumnDelimiter, VT_BSTR)
    DISP_PROPERTY(CDataObject, "IncludeNamesOnClipboard", m_fIncludeNamesOnClipboard, VT_BOOL)
    DISP_PROPERTY_EX(CDataObject, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CDataObject, "Visible", GetVisible, SetVisible, VT_BOOL)
    DISP_PROPERTY_EX(CDataObject, "Title", GetTitle, SetTitle, VT_BSTR)
    DISP_PROPERTY_EX(CDataObject, "FullName", GetFullName, SetNotSupported, VT_BSTR)
    DISP_PROPERTY_EX(CDataObject, "Name", GetName, SetNotSupported, VT_BSTR)
    DISP_PROPERTY_EX(CDataObject, "Path", GetPath, SetNotSupported, VT_BSTR)
    DISP_PROPERTY_EX(CDataObject, "Saved", GetSaved, SetNotSupported, VT_BOOL)
    DISP_PROPERTY_EX(CDataObject, "Active", GetActive, SetActive, VT_BOOL)
    DISP_PROPERTY_EX(CDataObject, "UpdateFrequency", GetUpdateFrequency, SetUpdateFrequency, VT_I4)
    DISP_PROPERTY_EX(CDataObject, "MostRecentOnly", GetMostRecentOnly, SetMostRecentOnly, VT_BOOL)
    DISP_PROPERTY_EX(CDataObject, "Username", GetUsername, SetUsername, VT_BSTR)
    DISP_PROPERTY_EX(CDataObject, "Password", GetPassword, SetPassword, VT_BSTR)
    DISP_PROPERTY_EX(CDataObject, "Status", GetStatus, SetNotSupported, VT_I4)
    DISP_FUNCTION(CDataObject, "Activate", Activate, VT_EMPTY, VTS_NONE)
    DISP_FUNCTION(CDataObject, "Close", Close, VT_VARIANT, VTS_VARIANT VTS_VARIANT)
    DISP_FUNCTION(CDataObject, "Save", Save, VT_VARIANT, VTS_NONE)
    DISP_FUNCTION(CDataObject, "SaveAs", SaveAs, VT_VARIANT, VTS_VARIANT)
    DISP_FUNCTION(CDataObject, "Copy", Copy, VT_EMPTY, VTS_NONE)
    //}}AFX_DISPATCH_MAP
    // BUGFIX: 9/29/94 cek 
    // Changed .Requests and .DataItems from DISP_FUNCTION to 
    // DISP_PROPERTY_PARAM (and changed return type to VARIANT)
    // so that xrt.Requests("Foo") works.
    //
    //DISP_FUNCTION(CDataObject, "Requests", Requests, VT_DISPATCH, VTS_VARIANT)
    //DISP_FUNCTION(CDataObject, "DataItems", DataItems, VT_DISPATCH, VTS_VARIANT)
    DISP_PROPERTY_PARAM(CDataObject, "Requests", Requests, SetNotSupported, VT_VARIANT, VTS_VARIANT)
    DISP_PROPERTY_PARAM(CDataObject, "DataItems", DataItems, SetNotSupported, VT_VARIANT, VTS_VARIANT)

    DISP_FUNCTION(CDataObject, "Quit", Close, VT_VARIANT, VTS_VARIANT VTS_VARIANT)
END_DISPATCH_MAP()

// CDataObjectView column info initialization data
//
// CDataObjectView (view.cpp) uses a "Column List Box" that is implemented
// in collist.cpp.   collist.h defines the COLINFO structure we initialize below.
// This structure tells the column list box how many columns to have and
// the formatting characteristics of each column.   Because we define a static
// structure of 10 columns we imply that XRTFrame has a limit of only 8 properties
// per request item (that is, the Request.Properties object can only support 8
// properties).  This is an implementation limitation of XRTFrame and can easily
// be rectified by writing the code that allows these structures to grow/shink.
// 
// There are 2 COLINFO structures:  One for Requests and one for DataItems
//
static COLINFO g_rgRequestsColInfo[] = 
    {
        //  uiWidth,      uiIndent,     uiFormatFlags
                 25,             0,          DT_LEFT,  // Request Index
                 90,             0,          DT_LEFT,  // Request.Request
                 50,             0,          DT_LEFT,  // Request.Properties(0) (name)
                 50,             0,          DT_LEFT,  // Request.Properties(1)
                 50,             0,          DT_LEFT,  
                 50,             0,          DT_LEFT,  
                 50,             0,          DT_LEFT,  
                 50,             0,          DT_LEFT,  
                 50,             0,          DT_LEFT,  
                 50,             0,          DT_LEFT,  
    }  ;
#define REQUESTSCOLINFO_NUMCOLS (sizeof(g_rgRequestsColInfo)/sizeof(g_rgRequestsColInfo[0]))
static char g_szRequestsTitle[] = "Idx\tRequest\tp0\tp1\tp2\tp3\tp4\tp5\tp6\tp7\tp8\tp9" ;

// CDataView column info initialization data
//
static COLINFO g_rgDataColInfo[] = 
    {
        //  uiWidth,      uiIndent,     uiFormatFlags
                 50,             0,          DT_LEFT,  // DataItem.Properties(0) (name)
                 50,             0,          DT_LEFT,  // DataItem.Properties(1)
                 50,             0,          DT_LEFT,  
                 50,             0,          DT_LEFT,  
                 50,             0,          DT_LEFT,  
                 50,             0,          DT_LEFT,  
                 50,             0,          DT_LEFT,  
                 50,             0,          DT_LEFT,  
                 50,             0,          DT_LEFT,  
    }  ;
#define DATAVIEWCOLINFO_NUMCOLS (sizeof(g_rgDataColInfo)/sizeof(g_rgDataColInfo[0]))
static char g_szDataViewTitle[] = "Name\tp1\tp2\tp3\tp4\tp5\tp6\tp7\tp8\tp9" ;

// This static member of CDataObject holds the value returned by
// RegisterClipboardFormat( "WOSA/XRT (Market Data)").
//
CLIPFORMAT CDataObject::m_cfPrivate = NULL;

// There are 2 classes implemented in this file. The following 2 lines make
// it so they both can be created dynamically by MFC
//
IMPLEMENT_DYNCREATE(CDataObject, COleServerDoc)
IMPLEMENT_DYNCREATE(CDataObjects, CCmdTarget)
#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CDataObject construction/destruction
CDataObject::CDataObject()
{
    // We don't really need OLE 2.0 compound file support in this sample
    // (e.g. IStorage based files).   So we turn it off.  On Win16 IStorage
    // files consume file handles quickly.   There are ways to give apps on
    // Win16 access to many many file handles, but we don't bother here.  See
    // MSDN for details on how to do this.
    //
    EnableCompoundFile( FALSE ) ;

    // All CCmdTarget derived classes can expose an IDispatch.  Calling
    // EnableAutomation sets this up.
    //
    EnableAutomation();

    // We keep 'counters' of Request objects, Property objects, and DataItem objects
    //
    m_dwRequestID = 0 ;
    m_dwPropertySetID = 0 ;
    m_dwDataItemID = 0 ;

    // Setup our column info.   We manage the column info in this class instead
    // of the view because we save column settings to our files as a neat UI feature.
    //
    m_rgRequestsColInfo = NULL ;
    m_rgDataColInfo = NULL ;
    SetRequestsColInfo( REQUESTSCOLINFO_NUMCOLS, g_rgRequestsColInfo, (LPCSTR)g_szRequestsTitle, FALSE ) ;
    SetDataColInfo( DATAVIEWCOLINFO_NUMCOLS, g_rgDataColInfo, (LPCSTR)g_szDataViewTitle, FALSE ) ;

    // determine default font
    memset(&m_logfont, 0, sizeof m_logfont);
    m_logfont.lfHeight = -10;
    static char BASED_CODE szArial[] = "Arial";
    lstrcpy(m_logfont.lfFaceName, szArial);
    m_logfont.lfOutPrecision = OUT_TT_PRECIS;
    m_logfont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    m_logfont.lfQuality = PROOF_QUALITY;
    m_logfont.lfPitchAndFamily = FF_SWISS | VARIABLE_PITCH;

    // Register the WOSA/XRT 1.0 clipboard format.
    //
    if (m_cfPrivate == NULL)
#if XRT_VER >= 0x0101
        // 1.01 Clipboard format name changed
        #ifdef _UNICODE
            // nb. XRTFrame has never been compiled with _UNICODE.  This is just
            // here for illustration
            //
        m_cfPrivate = (CLIPFORMAT)::RegisterClipboardFormat( szCF_WOSAXRT101W );
        #else
        m_cfPrivate = (CLIPFORMAT)::RegisterClipboardFormat( szCF_WOSAXRT101A );
        #endif
#else
        m_cfPrivate = (CLIPFORMAT)::RegisterClipboardFormat( szCF_WOSAXRT100 );
#endif

    m_pServerItem = NULL ;

    // Create the 'default' property set...contains one property:  "Name"
    //        
    CProperties* pProps = new CProperties(this) ;
    pProps->Add("Name") ;
    m_lstPropSets.AddHead( pProps ) ;

    // Grab the simulated data feed object
    //
    m_pSimulation = ((CMainFrame*)AfxGetMainWnd())->m_pSimulation ;
    m_uiSimID = 0   ;
    
    // m_uiUpdateFrequency is also serialzed, but this lets the user set a 
    // global default.  There is no UI for this in this sample, but it might
    // be nice to provide it in real objects.
    //
    // The CDataObject needs to get a timer tick every time UpdateFrequency
    // elapses.   Since CDataObject is not derived from CWnd it can't receive
    // WM_TIMER notifications direclty, so it creates a hidden child window
    // that get's them.
    //                   
    m_uiUpdateFrequency = AfxGetApp()->GetProfileInt( "Simulation", "UpdateFrequency", 5000 ) ;
    m_wndTimer.m_pDataObject = this ;
    m_wndTimer.Create( NULL, "Timer", WS_BORDER, CRect(0,0,50,50), AfxGetApp()->m_pMainWnd, 42 ) ;
    
    m_fMostRecentOnly = FALSE ;
    m_cColumnDelimiter = '\t' ;
    m_fIncludeNamesOnClipboard = TRUE ;
    
    m_pXRTData = NULL ;

    #ifdef _DEBUG
    m_pdbgDump = NULL ;
    #endif 
    AfxOleLockApp();
}

// Standard destructor
//
CDataObject::~CDataObject()
{   
    POSITION pos ;
    
    // Be a good boy and clean up all Request objects that may
    // have been created
    //
    CRequest* pItem ;
    for( pos = m_lstRequests.GetHeadPosition(); pos != NULL; )
    {
        pItem = (CRequest*)m_lstRequests.GetNext( pos ) ;
        ASSERT(pItem) ;
        // They can't exist outside of our DataObject so nuke
        // em!
        #ifdef USERELEASETODELETE
        if (pItem)
            pItem->ExternalRelease() ;
        #else 
        delete pItem ;
        #endif
    }

    // Be a good boy and clean up all Property set objects that may
    // have been created
    //
    CProperties* pProps ;
    for ( pos = m_lstPropSets.GetHeadPosition() ; pos != NULL ;)
    {
        pProps = (CProperties*)m_lstPropSets.GetNext( pos ) ;
        ASSERT(pProps) ;
        // They can't exist outside of our DataObject so nuke
        // em!
        #ifdef USERELEASETODELETE
        if (pProps)
            pProps->ExternalRelease() ;
        #else 
        delete pProps ;
        #endif
    }

    // Be a good boy and clean up all DataItem objects that may
    // have been created
    //
    CDataItem* pData ;
    for ( pos = m_lstDataItems.GetHeadPosition() ; pos != NULL ;)
    {
        pData = (CDataItem*)m_lstDataItems.GetNext( pos ) ;
        ASSERT(pData) ;
        // They can't exist outside of our DataObject so nuke
        // em!
        #ifdef USERELEASETODELETE
        if (pData)
            pData->ExternalRelease() ;
        #else 
        delete pData ;
        #endif
    }

    // Tell the simulation we're no longer interested in getting
    // data from it...
    //
    m_pSimulation->UnRegisterClient( m_uiSimID ) ;

    if (m_pXRTData != NULL)
        xrtDestroyMarketData( m_pXRTData ) ;

    if (m_rgRequestsColInfo != NULL)
        delete m_rgRequestsColInfo ;
        
    if (m_rgDataColInfo != NULL)
        delete m_rgDataColInfo ;

    m_wndTimer.DestroyWindow() ;
    
#ifdef _DEBUG_DMP
    xrtStopDebugDump( m_pdbgDump ) ;
#endif     
        
    AfxOleUnlockApp();
}

// Get the column info for the Requests list.  Returns
// the number of columns.
//
COLINFO* CDataObject::GetRequestsColInfo( int *pnCols , CString& rstrTitle ) 
{     
    rstrTitle = m_strRequestsTitle ;
    *pnCols = m_nRequestsCols ;
    return m_rgRequestsColInfo ;
}

// Change the # of columns (and formatting) in the requests list.   This
// is called when the user changes the width of a column so we can
// save his settings in the serialization.
//
void CDataObject::SetRequestsColInfo( int nCols, const COLINFO* pColInfo, const CString& rstrTitle, BOOL fDirty ) 
{
    m_nRequestsCols = nCols ;
    if (m_rgRequestsColInfo != NULL)
    {
        delete m_rgRequestsColInfo ;
    }
    m_rgRequestsColInfo = new COLINFO[nCols] ;
    ASSERT(m_rgRequestsColInfo);
    
    memcpy( m_rgRequestsColInfo, pColInfo, sizeof(COLINFO) * nCols) ; ;
    
    m_strRequestsTitle = rstrTitle ;
    
    if (fDirty)
    {
        SetModifiedFlag(TRUE) ;

        // BUGFIX:  9/14/94 CEK
        // Previously UpdateAllItems was being called regardless of the
        // setting of fDirty.   This caused the server item to do an
        // IAdviseSink::OnDataChange with the entire data set whenever
        // the window was sized.
        //
        UpdateAllItems(NULL, UPDATE_REQUEST_COLCHANGE, NULL) ;
    }
}

// Column handlers for the DataItem list
//
COLINFO* CDataObject::GetDataColInfo( int *pnCols , CString& rstrTitle ) 
{     
    rstrTitle = m_strDataViewTitle ;
    *pnCols = m_nDataCols ;
    return m_rgDataColInfo ;
}

void CDataObject::SetDataColInfo( int nCols, const COLINFO* pColInfo, const CString& rstrTitle, BOOL fDirty ) 
{
    m_nDataCols = nCols ;
    if (m_rgDataColInfo != NULL)
    {
        delete m_rgDataColInfo ;
    }
    m_rgDataColInfo = new COLINFO[nCols] ;
    ASSERT(m_rgDataColInfo);
    
    memcpy( m_rgDataColInfo, pColInfo, sizeof(COLINFO) * nCols) ; ;
    
    m_strDataViewTitle = rstrTitle ;
    
    if (fDirty)
        SetModifiedFlag(TRUE) ;
        
    UpdateAllItems(NULL, UPDATE_DATA_COLCHANGE, NULL) ;
}

// Helper to select the current document font into a DC.
// Called by both the view and the serveritems.
//
CFont* CDataObject::SelectDocFont(CDC* pDC, CFont& font)
{
    // convert points in m_logfont.lfHeight to logical
    LOGFONT logfont = m_logfont;
    logfont.lfHeight = -::MulDiv(-logfont.lfHeight,
        pDC->GetDeviceCaps(LOGPIXELSY), 72);

    // create the font object
    if (!font.CreateFontIndirect(&logfont))
        return NULL;

    // select the font
    return pDC->SelectObject(&font);
}
                       
// Returns the width necessary to display the current request or dataitem
// list.                                                         
// When embedded (active in place) we show the requests.
// When linked we show the data items.
//                       
int CDataObject::GetWidth( CDC* pDC, BOOL fLinked ) 
{       
    int wR = 0;
    int wD = 0 ;
    int i ;

    if (fLinked == FALSE)
    {    
        // Get the width of the requests view
        for (i = 0 ; i < m_nRequestsCols ; i++)
            wR += m_rgRequestsColInfo[i].uiWidth ;
    }
    
    // Get the width of the dataitem view
    for (i = 0 ; i < m_nDataCols ; i++)
        wD += m_rgDataColInfo[i].uiWidth ;

    return max( wR, wD ) ;
}
                       
void CDataObject::CalcDisplaySize( CDC* pDC, CSize& size, BOOL fLinked ) 
{
    // BUGBUG!
    // For now we force fLinked to be TRUE because COleServerItem::IsLinkedItem()
    // returns TRUE when OnGetClipboardData is called.   Once we figure out
    // how to fix this the following line of code should be removed
            fLinked = TRUE ;
    
    // select correct font for the document
    CFont font;
    CFont* pOldFont = SelectDocFont(pDC, font);
    
    size.cx = GetWidth( pDC, fLinked ) ;

    TEXTMETRIC tm ;
    pDC->GetTextMetrics( &tm ) ;
    
    // If we're linked then we only show the data items
    //
    if (fLinked == FALSE)
    {
        size.cy = tm.tmHeight * (m_lstRequests.GetCount() + 1) + 2 ;
        size.cy += tm.tmHeight * (m_lstDataItems.GetCount() + 1) + 2 ;
    }
    else
        size.cy += tm.tmHeight * (m_lstDataItems.GetCount()) + 2 ;
    
    // restore state of the dc
    if (pOldFont != NULL)
        pDC->SelectObject(pOldFont);
}

// This is called by the COleServerItem implementation to draw the
// "document" to a metafile.   
//
int CDataObject::Draw(CDC *pDC, CPoint ptStart, BOOL fLinked)
{
    // BUGBUG!
    // For now we force fLinked to be TRUE because COleServerItem::IsLinkedItem()
    // returns TRUE when OnGetClipboardData is called.   Once we figure out
    // how to fix this the following line of code should be removed
            fLinked = TRUE ;

    CFont font;
    CFont* pOldFont = SelectDocFont(pDC, font);
    if (pOldFont == NULL)
        return -1;

    int  nTotalWidth = GetWidth( pDC ) ;
                                  
    TEXTMETRIC tm ;
    pDC->GetTextMetrics( &tm ) ;
                                  
    RECT rc ;                             
    rc.left = ptStart.x ;
    rc.top = ptStart.y ;
    rc.bottom = ptStart.y + tm.tmHeight ;
    rc.right = rc.left ;
         
    COLORREF rgb ;
    LPTSTR psz ;
    int i, n ;
    POSITION pos;
        
    // If we're linked then we only show the data items
    //
    if (fLinked == FALSE)
    {
        // Draw the column headers by simulating what the CColumnListBox
        // implementation would do.
        //
        TCHAR szTemp[512] ;
        lstrcpy(szTemp, m_strRequestsTitle) ;
        psz = strtok( szTemp, _T("\t") ) ;
        for (i = 0 ; i < m_nRequestsCols ; i++)
        {        
            ASSERT(psz ) ;
            if (i == m_nRequestsCols-1)
                rc.right = ptStart.x + nTotalWidth ;
            else 
                rc.right += m_rgRequestsColInfo[i].uiWidth ;
            rgb = pDC->SetBkColor( GetSysColor( COLOR_BTNFACE) ) ;
            
            // Use CColumnListBox to help us make it look like real
            CColumnListBox::JustifiedTextOut( pDC, rc.left+2, rc.top, 
                               rc, psz, 0, m_rgRequestsColInfo[i].uiFormatFlags ) ;
            CColumnListBox::DrawBtnFrame( pDC, &rc, FALSE ) ;
            pDC->SetBkColor( rgb ) ;
            rc.left += m_rgRequestsColInfo[i].uiWidth ;
            psz = strtok( NULL, "\t" ) ;
        }
        
        ptStart.y += tm.tmHeight ;
        
        // Now draw each request in the list by calling it's Draw method
        //
        CRequest* pItem = NULL ;
        for( pos = m_lstRequests.GetHeadPosition(), n = 0; pos != NULL; n++ )
        {
            pItem = (CRequest*)m_lstRequests.GetNext( pos ) ;
            ASSERT_VALID(pItem);
            if (pItem)
            {
                ptStart.y += pItem->Draw(pDC, ptStart, n) ;
            }
        }

        rc.left = ptStart.x ;
        rc.top = ptStart.y ;
        rc.bottom = ptStart.y + tm.tmHeight ;
        rc.right = rc.left ;
    
        // Draw the column headings for the DataItem list.
        //
        lstrcpy(szTemp, m_strDataViewTitle ) ;
        psz = strtok( szTemp, _T("\t") ) ;
        for (i = 0 ; i < m_nDataCols ; i++)
        {        
            ASSERT(psz ) ;
            if (i == m_nDataCols-1)
                rc.right = ptStart.x + nTotalWidth ;
            else 
                rc.right += m_rgDataColInfo[i].uiWidth ;
            rgb = pDC->SetBkColor( GetSysColor( COLOR_BTNFACE) ) ;
            CColumnListBox::JustifiedTextOut( pDC, rc.left+2, rc.top, 
                               rc, psz, 0, m_rgDataColInfo[i].uiFormatFlags ) ;
            CColumnListBox::DrawBtnFrame( pDC, &rc, FALSE ) ;
            pDC->SetBkColor( rgb ) ;
            rc.left += m_rgDataColInfo[i].uiWidth ;
            psz = strtok( NULL, "\t" ) ;
        }
        ptStart.y += tm.tmHeight ;
    }

    // Draw each DataItem using the Draw method of CDataItem
    //
    CDataItem* pDataItem = NULL ;
    for( pos = m_lstDataItems.GetHeadPosition(), n = 0; pos != NULL; n++ )
    {
        pDataItem = (CDataItem*)m_lstDataItems.GetNext( pos ) ;
        ASSERT_VALID(pDataItem);
        if (pDataItem)
        {
            ptStart.y += pDataItem->Draw(pDC, ptStart, n) ;
        }
    }
   
    // restore state of the dc
    pDC->SelectObject(pOldFont);
    return 0 ;

}

void CDataObject::OnFinalRelease()
{
    COleServerDoc::OnFinalRelease() ;
}

BOOL CDataObject::OnNewDocument()
{
    if (!COleServerDoc::OnNewDocument())
        return FALSE;

#ifdef _DEBUG_DMP
    char szPath[256] ;
    lstrcpyn( szPath, GetTitle(), 8 ) ;
    char * p = strrchr(szPath, '.') ;
    if (p) 
        *p = '\0' ;
    lstrcat(szPath, ".DMP") ;
    m_pdbgDump = xrtStartDebugDump( szPath ) ;
#endif     

    return TRUE;
}

BOOL CDataObject::OnOpenDocument( const char* szFile)
{
    if (!COleServerDoc::OnOpenDocument(szFile))
        return FALSE;

#ifdef _DEBUG_DMP
    char szPath[256] ;
    if (szFile && *szFile)
        lstrcpy( szPath, szFile ) ;
    else
        lstrcpyn( szPath, GetTitle(), 8 ) ;

    char * p = strrchr(szPath, '.') ;
    if (p) 
        *p = '\0' ;
    lstrcat(szPath, ".DMP") ;    
    m_pdbgDump = xrtStartDebugDump( szPath ) ;
#endif     

    // Go through all items in the simulation seeing if there
    // is a match with our request list. 
    //
    // Note the outside loop iterates through the reqeust list
    // first.  This is not optimal for performance, but gives us
    // the ability to have the items in the dataitem list be in
    // the same order as the requests.   If this is not important
    // to you, iterate throught the stocks in the outer loop.
    //
    POSITION pos;
    CRequest* pRequest ;
    for( pos = m_lstRequests.GetHeadPosition(); pos != NULL; )
    {
        pRequest = (CRequest*)m_lstRequests.GetNext( pos ) ;
        if (pRequest)
        {
            PSIMSTOCK pStock = NULL ;
            UINT ui ;
            for (UINT n = 0 ; n <  m_pSimulation->GetCount() ; n++)
            {   
                pStock = m_pSimulation->GetStock( n ) ;
                ASSERT(pStock);
                if (pRequest->Match( pStock->szSymbol ))
                {
                    // Grab it!
                    ui = pStock->uiMembers ;
                    pStock->uiMembers = F_SIM_ALL ;   // Force all

                    // BUGFIX:  10/2/94 cek
                    // Added lHint parameter to UpdateDataItems.  Pass UPDATE_ALL
                    // to force the entire data item to be sent to the client
                    // (instead of just the changed properties).  Pass UPDATE_ADDREQUEST
                    // whenever a request is being added.
                    //
                    UpdateDataItems( pRequest, pStock, UPDATE_ALL ) ;
                    pStock->uiMembers = ui ;        // revert
                }
            }
       }
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CDataObject server implementation
//
COleServerItem* CDataObject::OnGetEmbeddedItem()
{
    // OnGetEmbeddedItem is called by the framework to get the COleServerItem
    //  that is associated with the document.  It is only called when necessary.

    CDataObjectSvrItem* pItem = new CDataObjectSvrItem(this);
    ASSERT_VALID(pItem);
    return pItem;
}

// OnGetLinkedItem is called whenever the framework is trying to find a 
// link item.  In otherwords, someone has attempted to bind to a 
// compound moniker and that binding process has resulted in the underlying
// OLE 2.0 server code in this app to be called.  
//
COleServerItem* CDataObject::OnGetLinkedItem(LPCSTR lpszItemName)
{
    USES_CONVERSION;
    // look in current list first
    COleServerItem* pItem = COleServerDoc::OnGetLinkedItem(lpszItemName);
    if (pItem != NULL)
        return pItem;

    char* pstr = NULL ;
    char* pstrItem = NULL;
    char* pstrProperty = NULL ;
    
    if (lpszItemName && *lpszItemName)
    {
        pstr = new char[lstrlen(lpszItemName)+1] ;
        lstrcpy( pstr, lpszItemName ) ;
        
        if (*pstr == '!')
            pstrItem = strtok(pstr+1, "/\\") ;
        else
            pstrItem = strtok(pstr, "/\\") ;
    }
    
    if (pstrItem != NULL && *pstrItem != '\0')
    {
        CDataItem* pDataItem = NULL ;
        
        POSITION pos ;
        for (pos = m_lstDataItems.GetHeadPosition() ; pos != NULL;)
        {
            pDataItem = (CDataItem*)m_lstDataItems.GetNext(pos) ;
            CProperty*  pProp = (CProperty*)pDataItem->m_pValueProps->m_lstProps.GetHead() ;
            if (pDataItem && (pProp->m_varValue.vt == VT_BSTR))
            {
                if (lstrcmp( OLE2T(pProp->m_varValue.bstrVal), pstrItem) == 0)
                    break ;
                else
                    pDataItem = NULL ;
            }
        }
        
        if (pDataItem)
        {
            // Is there anymore to the moniker?
            if (pstrProperty = strtok( NULL, "/\\" ))
            {
                ASSERT(pDataItem->m_pValueProps) ;
                CProperty* pProperty = pDataItem->m_pValueProps->Find( pstrProperty ) ;

                // Then find the SubProperty1 object....
                //
                // CProperty* pSubProp = NULL ;
                // while (pstrProperty = strtok( NULL, "/\\" ))
                // {
                //     pSubProp = pProperty->
                // }
                if (pProperty)
                {
                    ASSERT(pProperty->m_pServerItem == NULL);   // should not be connected
                    pItem = new CPropertyServerItem(this, pProperty);
                    ASSERT_VALID(pItem);
                }
                else
                {
                    TRACE("Didn't find property specified by moniker: %s\r\n", lpszItemName ) ;
                } 
            }   
            else
            {
                // Nope, he must want then entire item
                ASSERT(pDataItem->m_pServerItem == NULL);   // should not be connected
                pItem = new CDataItemServerItem(this, pDataItem);
                ASSERT_VALID(pItem);
            }
        }
    }
    else
    {
        TRACE( "OnGetLinkedDataItem called for entire DataItem set\r\n" ) ;
        if (m_pServerItem == NULL)
        {
            pItem = m_pServerItem = new CDataObjectSvrItem(this) ;
        }
        else
            pItem = m_pServerItem ;
            
        ASSERT_VALID(pItem) ;
    }

    if (pstr != NULL)
        delete pstr ;
        
    // return new item that matches lpszItemName
    return pItem;
}

/////////////////////////////////////////////////////////////////////////////
// CDataObject serialization
//      General "Document" type informaiton
//      - Font
//      - % size of CDataObjectView window (e.g. position of splitter)
//      - CDataObjectView state information
//          - Column widths
//      - CDataView state information
//          - Column widths
//      DataObject settings
//      - UpdateFrequency
//      - MostRecentOnly flag
//      - ColumnDelimiter character
//      List of Properties
//      List of Requests
//
void CDataObject::SerializeMiscInfo(CArchive& ar)
{
    // This helper is here because an earlier version of XRTFrame
    // tried to allow the embedding of single Request items.   Thus
    // the user could embed a single "Request" in Excel and double
    // click on it, and would get a "DataObject" with one Request
    // in it.  Hardly useful.  
    //
    TRACE("CDataObject::SerializeMiscInfo\r\n" ) ;

    if (ar.IsStoring())
    {
        ar.Write(&m_logfont,sizeof(LOGFONT));

        ar.Write(&m_nRequestsCols, sizeof(UINT) ) ;        
        ar.Write(m_rgRequestsColInfo, sizeof(COLINFO) * m_nRequestsCols ) ;
        ar << m_strRequestsTitle ;

        ar.Write(&m_nDataCols, sizeof(UINT) ) ;        
        ar.Write(m_rgDataColInfo, sizeof(COLINFO) * m_nDataCols ) ;
        ar << m_strDataViewTitle ;
        
        ar.Write(&m_uiUpdateFrequency, sizeof(UINT)) ;
        ar.Write(&m_fMostRecentOnly, sizeof(BOOL)) ;
        ar.Write(&m_cColumnDelimiter, sizeof(char)) ;
    }
    else
    {
        ar.Read(&m_logfont,sizeof(LOGFONT));

        ar.Read(&m_nRequestsCols, sizeof(UINT) ) ;        
        if (m_rgRequestsColInfo != NULL)
            delete m_rgRequestsColInfo ;
        m_rgRequestsColInfo = new COLINFO[m_nRequestsCols] ;
        ASSERT(m_rgRequestsColInfo) ;            
        ar.Read(m_rgRequestsColInfo, sizeof(COLINFO) * m_nRequestsCols ) ;
        ar >> m_strRequestsTitle ;

        ar.Read(&m_nDataCols, sizeof(UINT) ) ;        
        if (m_rgDataColInfo != NULL)
            delete m_rgDataColInfo ;
        m_rgDataColInfo = new COLINFO[m_nDataCols] ;
        ASSERT(m_rgDataColInfo) ;            
        ar.Read(m_rgDataColInfo, sizeof(COLINFO) * m_nDataCols ) ;
        ar >> m_strDataViewTitle ;
        
        ar.Read(&m_uiUpdateFrequency, sizeof(UINT)) ;
        
        if (m_wndTimer.IsRunning())
            m_wndTimer.SetFrequency( m_uiUpdateFrequency ) ;
        
        ar.Read(&m_fMostRecentOnly, sizeof(BOOL)) ;
        ar.Read(&m_cColumnDelimiter, sizeof(char)) ;
    }
}

void CDataObject::Serialize(CArchive& ar)
{
    TRACE("CDataObject::Serialize\r\n" ) ;
    SerializeMiscInfo(ar) ;
    if (!ar.IsStoring() && !m_lstPropSets.IsEmpty())
    {
        CProperties* p = (CProperties*)m_lstPropSets.GetHead() ;
        if (p) p->ExternalRelease() ;
        m_lstPropSets.RemoveAll() ;
    }
    m_lstPropSets.Serialize(ar) ;
    m_lstRequests.Serialize(ar);
}

DWORD CDataObject::GenerateRequestID()
{
    return ++m_dwRequestID ;
}

DWORD CDataObject::GeneratePropertySetID()
{
    return ++m_dwPropertySetID ;
}

DWORD CDataObject::GenerateDataItemID()
{
    return ++m_dwDataItemID ;
}

////////////////////////////////////////////////////////////////////////
// Internal Request manipluation methods
// 
// These functions provide an interface for other parts of XRTFrame
// to add, change, remove, etc... Request objects from the DataObject's
// list of requests.
//
int CDataObject::GetRequestCount( void ) 
{
    return m_lstRequests.GetCount() ;
}

CRequest* CDataObject::GetRequest( int index ) 
{
    POSITION pos = m_lstRequests.FindIndex( index ) ;
    if (pos != NULL)
        return (CRequest*)m_lstRequests.GetAt( pos ) ;
    
    return NULL ;
}

CRequest* CDataObject::GetRequest( const CString& rstrRequest ) 
{        
    POSITION pos;
    CRequest* pItem = NULL ;
    for( pos = m_lstRequests.GetHeadPosition(); pos != NULL; )
    {
        pItem = (CRequest*)m_lstRequests.GetNext( pos ) ;
        if (pItem)
        {
            if (lstrcmp( pItem->m_strRequest, rstrRequest ) == 0)
                break ;
        }
        pItem = NULL ;
    }
    
    return pItem ;
}

BOOL CDataObject::AddRequest( CRequest* pRequest ) 
{
    ASSERT(pRequest) ;
    m_lstRequests.AddTail( pRequest ) ;
    SetModifiedFlag( TRUE ) ;

    PSIMSTOCK pStock = NULL ;
    UINT ui ;
    for (UINT n = 0 ; n <  m_pSimulation->GetCount() ; n++)
    {   
        pStock = m_pSimulation->GetStock( n ) ;
        ASSERT(pStock);
        if (pRequest->Match( pStock->szSymbol ))
        {
            // Grab it!
            ui = pStock->uiMembers ;
            pStock->uiMembers = F_SIM_ALL ;   // Force all
            // BUGFIX:  10/2/94 cek
            // Added lHint parameter to UpdateDataItems.  Pass UPDATE_ALL
            // to force the entire data item to be sent to the client
            // (instead of just the changed properties).  Pass UPDATE_ADDREQUEST
            // whenever a request is being added.
            //
            UpdateDataItems( pRequest, pStock, UPDATE_ADDREQUEST ) ;
            pStock->uiMembers = ui ;        // revert
        }
    }
    
    UpdateAllViews( NULL, UPDATE_ADDREQUEST, pRequest ) ;

    // BUGFIX:  9/29/94 cek
    // Changed from UpdateAllItems( NULL, UPDATE_ADDREQUEST, pRequest ) to
    // :ForceOnDataChange so that only the added request would be sent.
    //
    ForceOnDataChange( UPDATE_ADDREQUEST) ;

    return TRUE ;
}

BOOL CDataObject::ChangeRequest( CRequest* pRequest, const CString& rstrRequest )
{
    if (pRequest)
    {
        pRequest->m_strRequest = rstrRequest ;
        SetModifiedFlag( TRUE ) ;
        UpdateAllViews( NULL, UPDATE_CHANGEREQUEST, pRequest ) ;    
        // BUGFIX:  9/29/94 cek
        // Changed from UpdateAllItems( NULL, UPDATE_CHANGEREQUEST, pRequest ) to
        // :ForceOnDataChange so that only the added request would be sent.
        //
        ForceOnDataChange( UPDATE_CHANGEREQUEST) ;
        return TRUE ;
    }
    return FALSE ;
}

CRequest* CDataObject::RemoveRequest( const CString& str ) 
{
    POSITION pos, pos2 ; 
    CRequest* pItem = NULL ;
    for( pos = m_lstRequests.GetHeadPosition(); pos != NULL; )
    {
        pos2 = pos ;
        pItem = (CRequest*)m_lstRequests.GetNext( pos ) ;
        if (pItem)
        {
            if (lstrcmpi( pItem->m_strRequest, str ) == 0)
            {
                m_lstRequests.RemoveAt( pos2 ) ;
                SetModifiedFlag( TRUE ) ;
                UpdateAllViews( NULL, UPDATE_REMOVEREQUEST, NULL ) ;
                // BUGFIX:  9/29/94 cek
                // Changed from UpdateAllItems( NULL, UPDATE_REMOVEREQUEST, pRequest ) to
                // :ForceOnDataChange so that only the added request would be sent.
                //
                ForceOnDataChange( UPDATE_REMOVEREQUEST) ;
                return  pItem;
            }
        }
    }
    return NULL ;
}

CRequest* CDataObject::RemoveRequest( CRequest* pRequest ) 
{
    POSITION pos = m_lstRequests.Find( pRequest ) ;
    if (pos != NULL)
    {
        m_lstRequests.RemoveAt( pos ) ;
        SetModifiedFlag( TRUE ) ;
        UpdateAllViews( NULL, UPDATE_REMOVEREQUEST, NULL ) ;
        // BUGFIX:  9/29/94 cek
        // Changed from UpdateAllItems( NULL, UPDATE_REMOVEREQUEST, pRequest ) to
        // :ForceOnDataChange so that only the added request would be sent.
        //
        ForceOnDataChange( UPDATE_REMOVEREQUEST) ;
    }
    return pRequest ;
}

CRequest* CDataObject::RemoveRequest( int index ) 
{   
    POSITION pos = m_lstRequests.FindIndex( index ) ;
    CRequest* pItem = NULL ;
    if (pos != NULL)
    {
        pItem = (CRequest*)m_lstRequests.GetAt( pos ) ;
        m_lstRequests.RemoveAt( pos ) ;
        SetModifiedFlag( TRUE ) ;
        UpdateAllViews( NULL, UPDATE_REMOVEREQUEST, NULL ) ;
        // BUGFIX:  9/29/94 cek
        // Changed from UpdateAllItems( NULL, UPDATE_REMOVEREQUEST, pRequest ) to
        // :ForceOnDataChange so that only the added request would be sent.
        //
        ForceOnDataChange( UPDATE_REMOVEREQUEST) ;
    }
    return pItem ;
}

////////////////////////////////////////////////////////////////////////
// Internal Property Set manipluation methods
// 
// These functions provide an interface for other parts of XRTFrame
// to add, change, remove, etc... Property set objects from the DataObject's
// list of CProperties objects.
//
BOOL CDataObject::AddPropertySet( CProperties* pProps ) 
{
    POSITION pos = m_lstPropSets.Find( pProps ) ;
    if (pos == NULL)
    {
        m_lstPropSets.AddTail( pProps ) ; 
        pProps->ExternalAddRef() ;
    }
    
    return TRUE ;
}

CProperties* CDataObject::GetNamePropertySet()
{
    CProperties* pFound = NULL ;
    pFound = (CProperties*)m_lstPropSets.GetHead() ;
    ASSERT(pFound) ;    // should always exist
    if (pFound)
        pFound->ExternalAddRef() ;
        
    return pFound ;
}

CProperties* CDataObject::FindPropertySet( CProperties* pProps ) 
{   
    CProperties* pFound = NULL ;
    POSITION pos ;
    pos = m_lstPropSets.Find( pProps ) ;
    if (pos != NULL)
        pFound = (CProperties*)m_lstPropSets.GetAt( pos ) ;
        
    if (pFound)
        pFound->ExternalAddRef() ;
                
    return pFound ;
}

CProperties* CDataObject::FindPropertySet( int index ) 
{   
    ASSERT(index != -1);
    
    CProperties* pFound = NULL ;
    POSITION pos ;
    pos = m_lstPropSets.FindIndex( index ) ;
    if (pos != NULL)
        pFound = (CProperties*)m_lstPropSets.GetAt( pos ) ;
        
    if (pFound)
        pFound->ExternalAddRef() ;
                
    return pFound ;
}

int CDataObject::GetPropertySetIndex( CProperties* pProperties )
{
    int i = 0 ;
    CProperties* pProps ;
    POSITION pos ;
        
    for( pos = m_lstPropSets.GetHeadPosition(); pos != NULL; )
    {
        pProps = (CProperties*)m_lstPropSets.GetNext( pos ) ;
        if (pProps == pProperties)
            return i ;
        i++ ;
    }    
    
    return -1 ;
}

//////////////////////////////////////////////////////////////////////
// Stuff dealing with the market data
//
// OnStockChange is called by the CSimulation class when a stock
// changes.   This is a key peice of code that would be replaced
// by a vendor who is attempting to use XRTFrame as a base for
// their WOSA/XRT development work.
//
void CDataObject::OnStockChange( PSIMSTOCK pStock )
{
    CRequest*   pRequest ;
    BOOL        fMatch = FALSE ;
    
    // See if he matches any of our reqeusts.  Note that he
    // may match more than one!
    //
    POSITION pos;
    for( pos = m_lstRequests.GetHeadPosition(); pos != NULL; )
    {
        pRequest = (CRequest*)m_lstRequests.GetNext( pos ) ;
        if (pRequest)
        {
            // The CRequest object implements a "Match" function
            // which returns TRUE or FALSE depending on whether
            // the passed string 'matches' it's request string.
            // The XRTFrame implementation of CRequest::Match simply
            // does a string compare....
            //
            if (pRequest->Match( pStock->szSymbol ))
            {
                // Grab it!
                // BUGFIX:  10/2/94 cek
                // Added lHint parameter to UpdateDataItems.  Pass UPDATE_ALL
                // to force the entire data item to be sent to the client
                // (instead of just the changed properties).  Pass UPDATE_ADDREQUEST
                // whenever a request is being added.
                //
                UpdateDataItems( pRequest, pStock, UPDATE_TIMEOUT ) ;
                fMatch = TRUE ;
                break ;
            }
        }
    } 
    
    if (fMatch)
        UpdateAllViews( NULL, UPDATE_MARKETCHANGE ) ;
}

// UpdateDataItems is called by the function above (OnStockChange) if
// a tick from the simulation matches some request.
//
// It is this function that generates the contents of a "WOSA/XRT (Market Data)"
// data stream (i.e. the WOSA/XRT Clipboard Format).   This function
// relies on a set of helper functions implemented in wosaxrt.cpp.  They all
// begin with xrt*.
//
// BUGFIX:  10/2/94 cek
// Added lHint parameter to UpdateDataItems.  Pass UPDATE_ALL
// to force the entire data item to be sent to the client
// (instead of just the changed properties).  Pass UPDATE_ADDREQUEST
// whenever a request is being added.
//
void CDataObject::UpdateDataItems( CRequest* pRequest, PSIMSTOCK pStock, LPARAM lHint )
{
    USES_CONVERSION;
    // pRequest points to the CRequest object that 'matched' the
    // stock tick from the simulation.   pStock is that stock tick.  See
    // simobj.cpp for the SIMSTOCK defintions.
    //
    CDataItem* pDataItem ;
    CProperties* pReqProps = pRequest->m_pProperties ;
    CProperties* pValProps ;
    CProperty* p ;
    CProperty* pProp ;
    POSITION pos ;
    VARIANT var ;
    VariantInit( &var ) ;

    // Does it already exist in the Request's list of dataitems?
    // (each CRequest contains a list of the "DataItem" objects that
    // it was responsible for).  The CRequest::FindDataItem member
    // hides the implementation of this.
    //
    pDataItem = pRequest->FindDataItem( pStock->szSymbol ) ;
    if (pDataItem == NULL)
    {   
        // Create and Add to m_lstDataItems and give it pRequest's propertyset
        //
        pDataItem = new CDataItem( this, pReqProps) ;
        m_lstDataItems.AddTail( pDataItem ) ;

        pos = pReqProps->m_lstProps.GetHeadPosition() ;
        pProp = (CProperty*)pReqProps->m_lstProps.GetNext(pos) ;
        p = new CProperty( this ) ;
        ASSERT(p) ;
        p->m_strName = "Name" ;
        p->m_varValue.vt = VT_BSTR ;
        p->m_varValue.bstrVal = SysAllocString( T2OLE(pStock->szSymbol) ) ;
        pDataItem->m_pValueProps->m_lstProps.AddTail(p) ;

        // Copy the property set...
        for (; pos != NULL ;)
        {
            pProp = (CProperty*)pReqProps->m_lstProps.GetNext(pos) ;
            ASSERT(pProp) ;

            p = new CProperty( this ) ;
            ASSERT(p) ;
            p->m_strName = pProp->m_strName ;
            VariantCopy( &p->m_varValue, &pProp->m_varValue ) ;
            pDataItem->m_pValueProps->m_lstProps.AddTail(p) ;
        }

		// BUGFIX:  9/19/94 cek  
		// Each data item needs to know which request was responsible for
		// it.
		//							 	
		pDataItem->m_dwRequestID = pRequest->m_dwID ;

        // Each request needs to know what DataItems it 'caused'
        pRequest->m_lstDataItems.AddTail( pDataItem ) ;        
        UpdateAllViews( NULL, UPDATE_ADDDATAITEM, pDataItem ) ;
    }
    
    ASSERT(pDataItem) ;
    pValProps = pDataItem->m_pValueProps ;

    if (m_pXRTData == NULL)
    {
        // If we don't have any data in our buffer yet create it.
        // This happens when we start up (obviously) and also each
        // time after we've notified our clients and sent them the data
        // via IAdviseSink::OnDataChange.
        //
        m_pXRTData = xrtCreateMarketData( &g_clsidDataObject ) ;
        ASSERT( m_pXRTData ) ;
        if (m_pXRTData == NULL) return ;
    }

    ASSERT( pReqProps ) ;
    
    // Look to see if this property set is already in there
    //
    LPPROPERTYSET lpPropSet = xrtFindPropertySet( m_pXRTData, pReqProps->m_dwID ) ;   
    LPUPDATEITEM  lpUpdateItem ;
    if (lpPropSet == 0)
    {
        // Nope.  Add a property set to the stream.
        lpPropSet = xrtAddPropertySet( &m_pXRTData, pReqProps->m_dwID) ;
        ASSERT( lpPropSet ) ;
        if (lpPropSet == NULL ) return ;
        for (pos = pReqProps->m_lstProps.GetHeadPosition() ;pos != NULL;)
        {
            pProp = (CProperty*)pReqProps->m_lstProps.GetNext(pos) ;
            if (!xrtAddProperty( &m_pXRTData, &lpPropSet, pProp->m_strName ))
            {
                ASSERT(0);
                return ;
            }
        }
    }

    // Allocate the update item
    #ifdef _DEBUG
    m_cItems ++ ;
    #endif

#if XRT_VER >= 0x0101
    lpUpdateItem = xrtAddUpdateItem( &m_pXRTData, 
                                     pDataItem->m_dwID, // 1.01 New Parameter
                                     pRequest->m_dwID, 
                                     pReqProps->m_dwID, pReqProps->m_lstProps.GetCount() ) ;
#else
    lpUpdateItem = xrtAddUpdateItem( &m_pXRTData, pRequest->m_dwID, 
                                     pReqProps->m_dwID, pReqProps->m_lstProps.GetCount() ) ;
#endif

    if (lpUpdateItem == NULL)
        return ;

    pos = pValProps->m_lstProps.GetHeadPosition() ;

    // BUGFIX:  10/2/94 cek
    // Act on new lHint parameter.   If the request has just
    // been added or the caller says update all, then don't
    // skip over the 'name' property.
    //
    int n = 0 ;
    if (lHint != UPDATE_ADDREQUEST)
    {
        // Skip past the 'name' property that exists by default.
        //
        pValProps->m_lstProps.GetNext(pos) ;           
        n++ ;
    }
    
    for (; pos != NULL ;n++)
    {
        pProp = (CProperty*)pValProps->m_lstProps.GetNext(pos) ;
        ASSERT(pProp) ;
        if ((pStock->uiMembers & F_SIM_HIGH) && pProp->m_strName == "High")
        {
            var.vt = VT_R8 ;
            var.dblVal = (double)pStock->ulHigh / (double)1000 ;
        }        
        else if ((pStock->uiMembers & F_SIM_LOW) && pProp->m_strName == "Low")
        {
            var.vt = VT_R8 ;
            var.dblVal = (double)pStock->ulLow / (double)1000 ;
        }        
        else if ((pStock->uiMembers & F_SIM_LAST) && pProp->m_strName == "Last")
        {
            var.vt = VT_R8 ;
            var.dblVal = (double)pStock->ulLast / (double)1000 ;
        }        
        else if ((pStock->uiMembers & F_SIM_VOLUME) && pProp->m_strName == "Volume")
        {
            var.vt = VT_I4 ;
            var.lVal = pStock->ulVolume ;
        }
        else if (pProp->m_strName == "Name")
        {
            var.vt = VT_BSTR ;
            var.bstrVal = SysAllocString( T2OLE(pStock->szSymbol) ) ;
        }
            
        // If any of the cases above succeeded var.vt won't be VT_EMPTY so
        // we know to slam the data into the stream.
        //
        if (var.vt != VT_EMPTY)
        {
            xrtAddUpdateItemProperty( &m_pXRTData, &lpUpdateItem, &var, n ) ;
            VariantCopy( &pProp->m_varValue, &var ) ;
            VariantClear( &var ) ;
            // Notify all links to Property objects (CPropertyServerItem) that the 
            // data has changed (e.g. do an IAdviseSink::OnDataChange)
            // Note this does not cause links to the entire Data*Object* to 
            // be notified.  That only happens on the UpdateFrequency timer
            //
            pProp->NotifyLinks() ;
        }
    }                         
    
    // Notify links to this data item that the data has 
    // changed (e.g. do an IAdviseSink::OnDataChange).   
    // Note this does not cause links to the entire Data*Object* to 
    // be notified.  That only happens on the UpdateFrequency timer
    //
    pDataItem->NotifyLinks() ;
}

// BUGFIX: 9/29/94 cek  
// Created ForceOnDataChange to isolate the places we force
// IAdviseSink::OnDataChange notifications.   This allows us
// to be more efficient about when we send notifications, so that
// repetitive data is not sent.
//
// lHint can be any of the #defines found in VIEW.H such
// as UPDATE_ALL, UPDATE_TIMEOUT, UPDATE_ADDREQUEST etc...
//
void CDataObject::ForceOnDataChange( LPARAM lHint)
{
    if (m_pXRTData && m_pServerItem != NULL)    
    {
            //TRACE("\r\n***Dump before...\r\n") ;
            //xrtDebugDump( afxDump, m_pXRTData ) ;
        m_pServerItem->m_fInSendOnDataChange = TRUE ;
        UpdateAllItems( NULL, lHint, NULL ) ;
        m_pServerItem->m_fInSendOnDataChange = FALSE ;
            //TRACE("***Dump after...\r\n") ;
            //xrtDebugDump( afxDump, m_pXRTData ) ;
    }
    
    // Always clear out the data set after a notify.
    //
    ClearDataItems() ;
}

// RenderToGlobal is called by the CDataObjectServerItem implementaiton
// when it get's a IDataObject::GetData call and that call was _not_ generated
// by an IAdviseHolder::SendOnDataChange.   In otherwords, if a real client
// object called our ::GetData function we render the entire data set.
//
BOOL CDataObject::RenderToGlobal( HGLOBAL* phGlobal ) 
{       
    ASSERT( phGlobal ) ;
    
    LPMARKETDATA    pXRT = NULL ;
    POSITION        pos ;
    POSITION        pos2 ;
    CDataItem*      pDataItem ;
    LPPROPERTYSET   lpPropSet ;
    LPUPDATEITEM    lpUpdateItem ;
    CProperty*      pProp ;   
    CProperties*    pReqProps ;

    if (*phGlobal == NULL)
    {    
        pXRT = xrtCreateMarketData( &g_clsidDataObject ) ;
    }
    else
    {
        pXRT = (LPMARKETDATA)GlobalLock(*phGlobal) ;
        pXRT = xrtCreateMarketData( &g_clsidDataObject, &pXRT ) ;        
    }
        
    ASSERT( pXRT ) ;

    for (pos = m_lstDataItems.GetHeadPosition() ;pos != NULL;)
    {
        pDataItem = (CDataItem*)m_lstDataItems.GetNext(pos) ;
        ASSERT(pDataItem) ;
        
        pReqProps = pDataItem->m_pRequestProps ;
        
        // Is this data item's property set already there?
        //
        lpPropSet = xrtFindPropertySet( pXRT, pReqProps->m_dwID ) ;   
        if (lpPropSet == 0)
        {
            // Nope.  Add a property set to the stream.
            lpPropSet = xrtAddPropertySet( &pXRT, pReqProps->m_dwID ) ;
            ASSERT( lpPropSet ) ;
            for (pos2 = pReqProps->m_lstProps.GetHeadPosition() ;pos2 != NULL;)
            {
                pProp = (CProperty*)pReqProps->m_lstProps.GetNext(pos2) ;
                if (!xrtAddProperty( &pXRT, &lpPropSet, pProp->m_strName ))
                {
                    ASSERT(0);
                    return FALSE ;
                }
            }
        }

		// BUGFIX:  9/19/94 cek  
		// We now pass pDataitem->m_dwRequestID to xrtAddUpdateItem (we were
        // passing 0 before)
		//		
        // Now add the item
        //    
        // Allocate the update item
        //

#if XRT_VER >= 0x0101
        lpUpdateItem = xrtAddUpdateItem( &pXRT, 
                                         pDataItem->m_dwID, // 1.01 New Parameter
                                         pDataItem->m_dwRequestID, 
                                         pReqProps->m_dwID, pReqProps->m_lstProps.GetCount() ) ;
#else
        lpUpdateItem = xrtAddUpdateItem( &pXRT, pDataItem->m_dwRequestID, 
                                         pReqProps->m_dwID, pReqProps->m_lstProps.GetCount() ) ;
#endif


        // For all properties on the DataItem add...
        //
        int n = 0 ;
        for (pos2 = pDataItem->m_pValueProps->m_lstProps.GetHeadPosition(); pos2 != NULL ;n++)
        {
            pProp = (CProperty*)pDataItem->m_pValueProps->m_lstProps.GetNext(pos2) ;
            ASSERT(pProp) ;            
            
            xrtAddUpdateItemProperty( &pXRT, &lpUpdateItem, &pProp->m_varValue, n ) ;
        }
    }

//    xrtDebugDump( afxDump, pXRT ) ;


    HGLOBAL h = GlobalPtrHandle( pXRT ) ;
    if (*phGlobal == NULL)
        GlobalUnlock(h) ;
    *phGlobal = h ;

    return TRUE ;
}

// BUGFIX: 9/29/94  Need to have a central place where the current
// data set is rendered for data transfer.   This is because every
// time it is rendered, it needs to be deleted.


// BUGFIX: 9/29/94  This isn't called from anywhere.  Commented out.
//BOOL CDataObject::RenderToStream( CArchive& ar )
//{
//    LPMARKETDATA    pXRT = NULL ;
//    HGLOBAL         h =  GlobalPtrHandle(pXRT) ;
//    if (RenderToGlobal( &h ))
//    {
//        ar.Write( pXRT, (int)pXRT->cbStream ) ;
//    
//        xrtDestroyMarketData( pXRT ) ;
//
//        return TRUE ;    
//    }
//    return FALSE ;
//}

// ClearDataItems is a helper that is called from various places to 
// "reset" the clipboard format buffer.
//
void CDataObject::ClearDataItems()
{
    if (m_pXRTData != NULL)
    {   
        #ifdef _DEBUG
        m_cItems = 0 ;
        #endif
        xrtDestroyMarketData( m_pXRTData ) ;
        m_pXRTData = NULL ;
    }
}

/////////////////////////////////////////////////////////////////////////////
// CDataObject diagnostics
#ifdef _DEBUG
void CDataObject::AssertValid() const
{
    COleServerDoc::AssertValid();
}

void CDataObject::Dump(CDumpContext& dc) const
{
    COleServerDoc::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CDataObject automation methods commands
//

// DataObject.Application.ShowAbout
//
LPDISPATCH CDataObject::GetApplication()
{
    LPDISPATCH  lpDisp = NULL ;
    CApplication* pApp = new CApplication ;
    
    if (pApp)
        lpDisp = pApp->GetIDispatch(FALSE) ;
    
    return lpDisp ;
}

// If DataObject.Visible Then...
//
BOOL CDataObject::GetVisible()
{
    POSITION pos = GetFirstViewPosition();
    CView* pView = GetNextView(pos);
    if (pView != NULL)
    {
        return pView->IsWindowVisible() ;
    }   
    
    return FALSE ;
}

// DataObject.Visible = False
//
void CDataObject::SetVisible(BOOL fVisible)
{
    POSITION pos = GetFirstViewPosition();
    CView* pView = GetNextView(pos);
    if (pView != NULL)
    {
        // Get the MDI child
        CFrameWnd* pFrameWnd = pView->GetParentFrame();

        if (fVisible)
        {    
            if (!pFrameWnd->IsWindowVisible())
                pFrameWnd->ShowWindow(SW_SHOWNA);
            
            pFrameWnd = pFrameWnd->GetParentFrame() ;                
            if (pFrameWnd && !pFrameWnd->IsWindowVisible())
                pFrameWnd->ShowWindow(SW_SHOWNA);
        }
        else
        {
            pFrameWnd->ShowWindow( SW_HIDE ) ;
        }        
    }   
    AfxOleSetUserCtrl( fVisible ) ;
}

// DataObject.Activate
//
// (brings window to front (also makes visible)
//
void CDataObject::Activate()
{
    SetVisible( TRUE ) ;
    
    POSITION pos = GetFirstViewPosition();
    CView* pView = GetNextView(pos);
    if (pView)
    {
        pView->ShowWindow( SW_SHOW ) ;
        CFrameWnd* pFrameWnd = pView->GetParentFrame();
        if (pFrameWnd)
            pFrameWnd->BringWindowToTop() ;
    }
}

// Debug.Print DataObject.Title
//
BSTR CDataObject::GetTitle()
{
    CString s;
    s = COleServerDoc::GetTitle( ) ;
    return s.AllocSysString();
}

// DataObject.Title = "Hello World"
//
void CDataObject::SetTitle(LPCSTR lpszNewValue)
{
    COleServerDoc::SetTitle( lpszNewValue ) ;
}

// Debug.Print DataObject.FullName
//
BSTR CDataObject::GetFullName()
{
    CString s = GetPathName() ;
    // BUGBUG:  Need to makesure it's the entire fullname
    return s.AllocSysString();
}

// Debug.Print DataObject.Name
//
BSTR CDataObject::GetName()
{
    CString s = GetPathName() ;
    // BUGBUG:  Need to extract just the filename
    return s.AllocSysString();
}

// Debug.Print DataObject.Path
//
BSTR CDataObject::GetPath()
{
    CString s = GetPathName() ;
    // BUGBUG:  Need to extract just the path
    return s.AllocSysString();
}

// If DataObject.Saved Then ...
//
BOOL CDataObject::GetSaved()
{
    return IsModified() ;
}

// DataObject.Close
//
// Forceful shutdown of DataObject
//
VARIANT CDataObject::Close(const VARIANT FAR& saveChanges, const VARIANT FAR& fileName)
{
    VARIANT va;
    VariantInit( &va ) ;

    if (saveChanges.vt == VT_BOOL)
    {
        if (saveChanges.bool == FALSE)
            SetModifiedFlag( FALSE ) ;
    }

    if (fileName.vt == VT_BSTR)
    {
        SaveAs( fileName ) ;
    }
         
    m_bAutoDelete = FALSE ;         
    OnCloseDocument() ;  
    m_bAutoDelete = TRUE ;

    return va;
}

// DataObject.Save
// 
// Save with current filename
//
VARIANT CDataObject::Save()
{
    VARIANT va;
    VariantInit( &va ) ;
    
    OnSaveDocument( GetPathName() ) ;
    
    return va;
}

// DataObject.SaveAs "FOO.XRF"
//
VARIANT CDataObject::SaveAs(const VARIANT FAR& fileName)
{
    VARIANT va;
    VariantInit( &va ) ;
    USES_CONVERSION;    
    if (fileName.vt == VT_BSTR)
        SetPathName( OLE2T(fileName.bstrVal) ) ;
    
    OnSaveDocument( GetPathName() ) ;
    
    return va;
}

// Set reqs = DataObject.Requests
//
VARIANT CDataObject::Requests(const VARIANT FAR& item)
{
    // BUGFIX: 9/29/94 cek 
    // Changed .Requests and .DataItems from DISP_FUNCTION to 
    // DISP_PROPERTY_PARAM (and changed return type to VARIANT)
    // so that xrt.Requests("Foo") works.
    //
    VARIANT va ;
    VariantInit( &va ) ;
    va.vt = VT_DISPATCH ;

    CRequests* pItems = new CRequests(this) ;
    
    ASSERT(pItems) ;
    if (pItems == NULL || !pItems->IsKindOf(RUNTIME_CLASS(CRequests)))
    {
        // TODO:  raise exception
        va.pdispVal = NULL ;
    }
    else if (item.vt == VT_ERROR || item.vt == VT_EMPTY)
    {
        va.pdispVal  = pItems->GetIDispatch(FALSE) ;    
    }
    else
    {
        va.pdispVal  = pItems->GetItem( item ) ;
        delete pItems ;
    }
    return va ;
}

// Set items = DataObject.DataItems
//
VARIANT CDataObject::DataItems(const VARIANT FAR& item)
{
    // BUGFIX: 9/29/94 cek 
    // Changed .Requests and .DataItems from DISP_FUNCTION to 
    // DISP_PROPERTY_PARAM (and changed return type to VARIANT)
    // so that xrt.Requests("Foo") works.
    //
    VARIANT va ;
    VariantInit( &va ) ;
    va.vt = VT_DISPATCH ;

    CDataItems* pItems = new CDataItems(this) ;
    
    ASSERT(pItems) ;
    if (pItems == NULL || !pItems->IsKindOf(RUNTIME_CLASS(CDataItems)))
    {
        // TODO:  raise exception
        va.pdispVal = NULL ;
    }
    else if (item.vt == VT_ERROR || item.vt == VT_EMPTY)
    {
        va.pdispVal  = pItems->GetIDispatch(FALSE) ;    
    }
    else
    {
        va.pdispVal  = pItems->GetItem( item ) ;
        delete pItems ;
    }
    return va ;
}

// If DataObject.Active = False Then ...
//
BOOL CDataObject::GetActive()
{
    return  m_uiSimID != 0 ;
}
 
// DataObject.Active = True 
//
void CDataObject::SetActive(BOOL fActive)
{
    if (fActive == TRUE)
    {
        if (m_uiSimID == 0)
        {
            m_uiSimID = m_pSimulation->RegisterClient( (LPVOID)this ) ;
        }
    }
    else
    {
        m_pSimulation->UnRegisterClient( m_uiSimID ) ;
        m_uiSimID = 0 ;
    }
    
    if (fActive == FALSE)
       m_wndTimer.SetFrequency( 0 ) ;
    else
       m_wndTimer.SetFrequency( m_uiUpdateFrequency ) ;
}

// DataObject.UpdateFrequency [get/set BOOL]
//
long CDataObject::GetUpdateFrequency()
{
    return m_uiUpdateFrequency ;
}

void CDataObject::SetUpdateFrequency(long nNewValue)
{   
    m_uiUpdateFrequency = (UINT)nNewValue ;

    if (m_wndTimer.IsRunning())
    {
        m_wndTimer.SetFrequency( m_uiUpdateFrequency ) ;
    }
}

// DataObject.MostRecentOnly [get/set BOOL]
//
BOOL CDataObject::GetMostRecentOnly()
{
    return m_fMostRecentOnly ;
}

void CDataObject::SetMostRecentOnly(BOOL bNewValue)
{
    m_fMostRecentOnly = bNewValue ;
}

// DataObject.Username [get/set string]
//
BSTR CDataObject::GetUsername()
{
    return m_strUsername.AllocSysString();
}

void CDataObject::SetUsername(LPCSTR lpszNewValue)
{
    m_strUsername = lpszNewValue ;
}

// DataObject.Password [get/set string]
//
BSTR CDataObject::GetPassword()
{
    return m_strPassword.AllocSysString();
}

void CDataObject::SetPassword(LPCSTR lpszNewValue)
{
    m_strPassword = lpszNewValue ;
}

// Debug.Print DataObject.Status
//
long CDataObject::GetStatus()
{
    // TODO: Add your property handler here
    return xrtStatusNormal ;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CDataObjects
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CDataObjects is the 'collection' object exposed via Automation as 
// "DataObjects".   It is a collection of DataObject objects (which are
// really implemneted as MFC 2.5 "CDocument" documents)
//
CDataObjects::CDataObjects()
{
    EnableAutomation();
    AfxOleLockApp();
}

CDataObjects::~CDataObjects()
{
    AfxOleUnlockApp();
}

void CDataObjects::OnFinalRelease()
{
    // When the last reference for an automation object is released
    //  OnFinalRelease is called.  This implementation deletes the 
    //  object.  Add additional cleanup required for your object before
    //  deleting it from memory.

    delete this;
}


BEGIN_MESSAGE_MAP(CDataObjects, CCmdTarget)
    //{{AFX_MSG_MAP(CDataObjects)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CDataObjects, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CDataObjects)
    DISP_PROPERTY_EX(CDataObjects, "Count", GetCount, SetNotSupported, VT_I2)
    DISP_FUNCTION(CDataObjects, "Add", Add, VT_VARIANT, VTS_VARIANT )
    DISP_FUNCTION(CDataObjects, "Open", Open, VT_VARIANT, VTS_VARIANT)
    //}}AFX_DISPATCH_MAP
    DISP_FUNCTION(CDataObjects, "Item", GetItem, VT_DISPATCH, VTS_VARIANT )
    DISP_DEFVALUE(CDataObjects, "Item")
    DISP_PROPERTY_EX_ID(CDataObjects, "_NewEnum", DISPID_NEWENUM, _NewEnum, SetNotSupported, VT_UNKNOWN)
END_DISPATCH_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDataObjects message handlers
//
//  object.Add()
//      Creates a new Document object.  The new Document becomes the
//      active document.
//      Returns the newly created Document.
//
VARIANT CDataObjects::Add( const VARIANT FAR& name)
{
    VARIANT va;
    VariantInit( &va ) ;
    POSITION pos ;   
    USES_CONVERSION;
    
    va.vt = VT_EMPTY ;

    // HACK:  Assume only one doc template for now...
    pos = AfxGetApp()->GetFirstDocTemplatePosition() ; 
    if (pos != NULL)
    {
        CDocTemplate* pTemplate = (CDocTemplate*)AfxGetApp()->GetNextDocTemplate( pos ) ;
        CDocument* pItem = pTemplate->OpenDocumentFile(NULL, TRUE );    // make visible
        
        if (pItem != NULL)
        {
            va.vt = VT_DISPATCH ;
            va.pdispVal = pItem->GetIDispatch(TRUE) ;
            if (name.vt == VT_BSTR)
                pItem->SetTitle( OLE2T(name.bstrVal) ) ;
        }    
    }
    return va;
}

// object.Open( fileName )
//      Opens a document
//
//      fileName is required.
//
//      Returns the Document object
//
VARIANT CDataObjects::Open(const VARIANT FAR& fileName)
{
    VARIANT va;
    VariantInit( &va ) ;
    CDocument* pItem ;
    USES_CONVERSION;
    
    va.vt = VT_EMPTY ;
    
    if (fileName.vt == VT_BSTR)
    {
        pItem = AfxGetApp()->OpenDocumentFile( OLE2T(fileName.bstrVal) )  ;
        if (pItem != NULL)
        {
            va.vt = VT_DISPATCH ;
            va.pdispVal = pItem->GetIDispatch(TRUE) ;
        }    
    }
    return va;
}

// object.Count
//      Returns the number of open documents
//
short CDataObjects::GetCount()
{
    // HACK:  Assume only one doc template for now...
    POSITION pos = AfxGetApp()->GetFirstDocTemplatePosition() ; 
    CDocTemplate* pTemplate = (CDocTemplate*)AfxGetApp()->GetNextDocTemplate( pos ) ;
    pos = pTemplate->GetFirstDocPosition() ;
    short n = 0 ;
    while (pos != NULL && pTemplate->GetNextDoc( pos ))
        n++ ;
    return n ;
}

// object.Item( index )
//      Returns the Document specified by index.  index can either
//      be a document name or number
//
LPDISPATCH CDataObjects::GetItem( const VARIANT FAR& vt )
{   
    CDocument* pItem = NULL ;  
    LPDISPATCH lpDisp = NULL ;
    USES_CONVERSION;

    // HACK:  Assume only one doc template for now...
    POSITION pos = AfxGetApp()->GetFirstDocTemplatePosition() ; 
        
    CDocTemplate* pTemplate = (CDocTemplate*)AfxGetApp()->GetNextDocTemplate( pos ) ;
    
    pos = pTemplate->GetFirstDocPosition() ;
    if (pos == NULL)
        return NULL ;

    if (vt.vt == VT_BSTR)
    {
        // for each document compare...
        while (pos != NULL)
        {
            pItem = pTemplate->GetNextDoc( pos ) ;
            if (pItem)
            {
                if (lstrcmpi( pItem->GetTitle(), OLE2T(vt.bstrVal) ) == 0)
                    break ;
            }
        }
    }
    else
    {
        // coerce to VT_I4
        VARIANT va ;
        VariantInit( &va );
        if (SUCCEEDED(VariantChangeType( &va, (VARIANT FAR*)&vt, 0, VT_I4 )))
        {
            pItem = pTemplate->GetNextDoc( pos ) ;
            while(va.lVal)
            {
                if (pos == NULL)
                {
                    // off the end..
                    pItem = NULL ;
                    break ;
                }
                else
                {
                    pItem = pTemplate->GetNextDoc( pos ) ;
                }
                va.lVal-- ;
            }
        }
    }                 
    
    if (pItem != NULL)
        lpDisp = pItem->GetIDispatch(TRUE) ;        // AddRef

    // BUGBUG:  Implement dispatch exception if lpDisp == NULL
    return lpDisp ;
}


// _NewEnum is a hidden method called by VBA during "For Each"
// processing
//
LPUNKNOWN CDataObjects::_NewEnum()
{
    CEnumDocs* pIEV = NULL ;

    pIEV = new CEnumDocs ;
    
    if (pIEV)
    {
        pIEV->m_xEnumVARIANT.Reset() ;
        return &pIEV->m_xEnumVARIANT ;
    }
    
    return NULL ;
}

//----------------------------------------------------------------------------
// Implementation of CEnumDocs which implements the IEnumVARIANT interface
// used by _NewEnum
//
BEGIN_INTERFACE_MAP(CEnumDocs, CCmdTarget)
    INTERFACE_PART(CEnumDocs, IID_IEnumVARIANT, EnumVARIANT)
END_INTERFACE_MAP()

CEnumDocs::CEnumDocs()
{
    //TRACE("CEnumVARAINT::CEnumDocs()\r\n" ) ;
    
    AfxOleLockApp();
}

CEnumDocs::~CEnumDocs()
{
    //TRACE("CEnumVARAINT::~CEnumDocs()\r\n" ) ;
    AfxOleUnlockApp();
}

void CEnumDocs::OnFinalRelease()
{
    // When the last reference for an automation object is released
    //  OnFinalRelease is called.  This implementation deletes the 
    //  object.  Add additional cleanup required for your object before
    //  deleting it from memory.
    //TRACE("CEnumDocs::OnFinalRelease\r\n" ) ;
    delete this;
}

//----------------------------------------------------------------------------
// Implementation of the nested class XEnumVARIANT (declared through the
// BEGIN/END_INTERFACE_PART macros in the declaration of CEnumDocs)
//
// This class implements the IEnumVARIANT interface requried by the 
// _NewEnum property of the collection
//
CEnumDocs::XEnumVARIANT::XEnumVARIANT()
{
    m_posCurrent = NULL ;
}

STDMETHODIMP_(ULONG) CEnumDocs::XEnumVARIANT::AddRef()
{   
    METHOD_PROLOGUE(CEnumDocs, EnumVARIANT)
    return pThis->ExternalAddRef() ;
}   

STDMETHODIMP_(ULONG) CEnumDocs::XEnumVARIANT::Release()
{   
    METHOD_PROLOGUE(CEnumDocs, EnumVARIANT)
    return pThis->ExternalRelease() ;
}   

STDMETHODIMP CEnumDocs::XEnumVARIANT::QueryInterface( REFIID iid, void FAR* FAR* ppvObj )
{   
    METHOD_PROLOGUE(CEnumDocs, EnumVARIANT)
    return (HRESULT)pThis->ExternalQueryInterface( (void FAR*)&iid, ppvObj) ;
}   

// IEnumVARIANT::Next
// 
STDMETHODIMP CEnumDocs::XEnumVARIANT::Next( ULONG celt, VARIANT FAR* rgvar, ULONG FAR* pceltFetched)
{
    // This sets up the "pThis" pointer so that it points to our
    // containing CRequests instance
    //
    METHOD_PROLOGUE(CEnumDocs, EnumVARIANT)

    HRESULT hr;
    ULONG   l ;
    CDocument*  pItem = NULL ;
    POSITION pos = AfxGetApp()->GetFirstDocTemplatePosition() ; 
    CDocTemplate* pTemplate = (CDocTemplate*)AfxGetApp()->GetNextDocTemplate( pos ) ;

    // pceltFetched can legally == 0
    //                                           
    if (pceltFetched != NULL)
        *pceltFetched = 0;
    else if (celt > 1)
    {   
        TRACE("XEnumVARIANT::Next() celt > 1 and pceltFetched == NULL!\r\n", celt ) ;
        return ResultFromScode( E_INVALIDARG ) ;   
    }

    for (l=0; l < celt; l++)
        VariantInit( &rgvar[l] ) ;

    // Retrieve the next celt elements.
    hr = NOERROR ;
    for (l = 0 ; m_posCurrent != NULL && celt != 0 ; l++)
    {   
        pItem = pTemplate->GetNextDoc( m_posCurrent ) ;
        celt-- ;
        if (pItem)
        {
            //TRACE( "   Setting rgvar[%d]\r\n", (int)l ) ;
            rgvar[l].vt = VT_DISPATCH ;
            rgvar[l].pdispVal = pItem->GetIDispatch( TRUE ) ;
            if (pceltFetched != NULL)
                (*pceltFetched)++ ;
        }
        else 
        {
            TRACE("GetNext failed in IEnumVARIANT::Next\r\n" ) ;
            return ResultFromScode( E_UNEXPECTED ) ;
        }
    }
    
    if (celt != 0)
    {
        //TRACE( "   End of list...celt == %d\r\n", (int)celt ) ;
        hr = ResultFromScode( S_FALSE ) ;
    }
    
    return hr ;
}

// IEnumVARIANT::Skip
//
STDMETHODIMP CEnumDocs::XEnumVARIANT::Skip(unsigned long celt) 
{
    METHOD_PROLOGUE(CEnumDocs, EnumVARIANT)
    POSITION pos = AfxGetApp()->GetFirstDocTemplatePosition() ; 
    CDocTemplate* pTemplate = (CDocTemplate*)AfxGetApp()->GetNextDocTemplate( pos ) ;

    //TRACE("XEnumVARIANT::Skip( %l )\r\n", celt ) ;
    
    while (m_posCurrent != NULL && celt--)
        pTemplate->GetNextDoc( m_posCurrent ) ;
    
    return (celt == 0 ? NOERROR : ResultFromScode( S_FALSE )) ;
}

STDMETHODIMP CEnumDocs::XEnumVARIANT::Reset()
{
    METHOD_PROLOGUE(CEnumDocs, EnumVARIANT)
    //TRACE("XEnumVARIANT::Reset()\r\n") ;
    POSITION pos = AfxGetApp()->GetFirstDocTemplatePosition() ; 
    CDocTemplate* pTemplate = (CDocTemplate*)AfxGetApp()->GetNextDocTemplate( pos ) ;
    m_posCurrent = pTemplate->GetFirstDocPosition() ;
    
    return NOERROR ;
}

STDMETHODIMP CEnumDocs::XEnumVARIANT::Clone(IEnumVARIANT FAR* FAR* ppenum) 
{
    METHOD_PROLOGUE(CEnumDocs, EnumVARIANT)   
    //TRACE("XEnumVARIANT::Clone()\r\n" ) ;

    CEnumDocs* p = new CEnumDocs ;
    if (p)
    {
        p->m_xEnumVARIANT.m_posCurrent = m_posCurrent ;
        return NOERROR ;    
    }
    else
        return ResultFromScode( E_OUTOFMEMORY ) ;
}


void CDataObject::OnOptionsActive()
{
    SetActive( m_uiSimID == 0 ) ;        
}

void CDataObject::OnUpdateOptionsActive(CCmdUI* pCmdUI)
{
    pCmdUI->SetCheck( m_uiSimID == 0 ? 0 : 1 ) ;
}

void CDataObject::OnEditCopyAll()
{
    if (m_pServerItem == NULL)
        m_pServerItem = new CDataObjectSvrItem(this);
    ASSERT_VALID(m_pServerItem);

    m_pServerItem->CopyToClipboard(TRUE);
    
}

void CDataObject::OnUpdateEditCopyAll(CCmdUI* pCmdUI)
{
    pCmdUI->Enable( !m_lstDataItems.IsEmpty() ) ;
}


void CDataObject::Copy()
{
    if (m_pServerItem == NULL)
        m_pServerItem = new CDataObjectSvrItem(this);
    ASSERT_VALID(m_pServerItem);

    m_pServerItem->CopyToClipboard(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CTimerWnd
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CTimerWnd is used by CDataObject as a place to recieve timer notifications.
// These notifications are used to support the "UpdateFrequency" feature of
// a WOSA/XRT DataObject.   Ever "UpdateFrequency" milliseconds the DataObject
// will send the latest data to the data user via Uniform Data Transfer
// (IAdviseSink).
//
CTimerWnd::CTimerWnd( )
{
    m_uiIDTimerEvent = 0 ;    
    m_pDataObject = 0 ;
}

CTimerWnd::~CTimerWnd()
{
}

void CTimerWnd::SetFrequency( UINT uiFreq )
{
    if (m_uiIDTimerEvent != 0)
    {
        KillTimer( m_uiIDTimerEvent ) ;
        m_uiIDTimerEvent = 0 ;
    }

    if (uiFreq != 0)
        m_uiIDTimerEvent = SetTimer( 1, uiFreq, NULL ) ;
}

BOOL CTimerWnd::IsRunning() 
{
    return m_uiIDTimerEvent != 0 ;
}

BEGIN_MESSAGE_MAP(CTimerWnd, CWnd)
    //{{AFX_MSG_MAP(CTimerWnd)
    ON_WM_DESTROY()
    ON_WM_TIMER()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTimerWnd message handlers

void CTimerWnd::OnDestroy() 
{
    CWnd::OnDestroy();

    if (m_uiIDTimerEvent != 0)
        KillTimer( m_uiIDTimerEvent ) ;
    m_uiIDTimerEvent = 0 ;    
}

void CTimerWnd::OnTimer(UINT nIDEvent) 
{
    ASSERT(m_pDataObject) ;
    
    if (m_pDataObject == NULL) return ;
    
    // BUGFIX: 9/29/94 cek 
    // Created CDataObject::ForceOnDataChange and moved code from
    // here into it to encapsulate/isolate.
    //
    m_pDataObject->ForceOnDataChange( UPDATE_TIMEOUT ) ;

    CWnd::OnTimer(nIDEvent);
}

#ifdef _DEBUG
#include "windowsx.h"

void WINAPI xrtDebugDumpItems( CDumpContext& ar, LPMARKETDATA pMD ) ;

CDumpContext* WINAPI xrtStartDebugDump( CString s ) 
{
    CFile *pf  ;
    
    TRY
    {   
        pf = new CFile( s, CFile::modeCreate | CFile::modeWrite ) ;
    }
    CATCH( CFileException, e )
    {
        #ifdef _DEBUG 
        afxDump << "File Exception " << e->m_cause << " (" << s << ")\n" ;
        #endif    
        delete pf ;
        return NULL ;
    }    
    END_CATCH
    
    CDumpContext* par = new CDumpContext( pf ) ; 
    
    afxDump << "xrtDebug started on " << s << "\n";
    return par ;
}

void WINAPI xrtStopDebugDump( CDumpContext* par )
{
    if (par == NULL) return ;
    
    par->Flush() ;
    delete par ;
}

CString _strADDR( LPVOID p );
CString _strDWORD( DWORD d );
CString _strLONG( LONG d );
CString _strVARTYPE( VARTYPE vt ) ;
CString _strVARIANT( VARIANT *pvar ) ;

#define _NAME(a)    #a
#define _ADDRESS(a) "\t" << _strADDR(&(##a)) << ">\t"  << #a  << " = " 
#define _L(d)   _ADDRESS(d) << _strLONG(d) << "\n" 
#define _H(d)   _ADDRESS(d) << _strDWORD(d) << "\n" 
#define _D(d)   _ADDRESS(d) << d << "\n" 
#define _S(d)   "\t" << _strADDR((##d)) << ">\t" << #d << " = " << d << "\n" 
#define _PV(d)  "\t" << _strADDR((##d)) << ">\t" << #d << " (" << _strVARTYPE(d->vt) << ") = " << _strVARIANT(d) << "\n"

void WINAPI xrtDebugDump( CDumpContext& ar, LPMARKETDATA pMD )
{
        
    ar << "***************** xrtDebugDump\n" ;
    ar << "Dumping (LPMARKETDATA) : " << _strADDR(pMD) << " GlobalSize == " << _strDWORD(GlobalSize(GlobalPtrHandle(pMD))) <<"\n" ;
    ar << _H(pMD->cbStream);
//    ar << _ADDR(pMD->clsID)         " = " << _DWORD(pMD->clsID) << "\n" ;
    ar << _L(pMD->dwStatus) ;
    ar << _L(pMD->dwSubStatus) ;
    ar << _H(pMD->dwVendorData1) ;
    ar << _H(pMD->dwVendorData2) ;
    ar << _H(pMD->dwPropSetOffset) ;
    ar << _H(pMD->dwItemOffset) ;

    xrtDebugDumpPropSets( ar, pMD ) ;
    
    xrtDebugDumpItems( ar, pMD ) ;
    
    ar << "\n\n" ;
    ar.Flush() ;
}

void WINAPI xrtDebugDumpPropSets( CDumpContext& ar, LPMARKETDATA pMD )
{
    ar << "\n*** Property Sets ***\n" ;

    LPPROPERTYSET  pPS = NULL ;
    DWORD dwOffset = pMD->dwPropSetOffset ;
    
    while (dwOffset != NULL) 
    {
        pPS = (LPPROPERTYSET)((BYTE FAR*)pMD + dwOffset) ;
        ar << "Property Set at " << _strADDR(pPS) << "\n" ;
        ar << _L(pPS->dwPropertySetID) ;
        ar << _L(pPS->cProperties) ;
        ar << _H(pPS->dwNext) ;
            
        LPSTR szName = NULL ;
        DWORD dw = sizeof(PROPERTYSET) ;
        DWORD FAR* pcbName = NULL ;
        for (DWORD c = 0 ; c < pPS->cProperties ; c++)
        {
            ar << "\tProperty [" << c << "]\n" ;
            pcbName = (LPDWORD)((LPBYTE)pPS +  dw) ;
            dw += sizeof(DWORD) ;
            ar << _L(*pcbName) ;
            szName = (LPSTR)((LPBYTE)pPS + dw) ;
            ar << _S(szName) ;
            dw += *pcbName ;
        }
        
        dwOffset = pPS->dwNext ;
    }
    
}

void WINAPI xrtDebugDumpItems( CDumpContext& ar, LPMARKETDATA pMD )
{
    ar << "\n*** Update Items ***\n" ;
    
    LPUPDATEITEMPROP pUIP ;
    LPUPDATEITEM  pUI = NULL ;
    DWORD dwOffset = pMD->dwItemOffset ;
    DWORD c ; 
    VARIANT *pvar ;
    
    while (dwOffset != NULL) 
    {
        pUI = (LPUPDATEITEM)((BYTE FAR*)pMD + dwOffset) ;
        ar << "Update Item at " << _strADDR(pUI) << "\n" ;
        ar << _L(pUI->dwRequestID) ;
        ar << _L(pUI->cProperties) ;
        ar << _H(pUI->dwNext) ;
        ar << _H(pUI->dwPropertySet) ;
        
        pUIP = (LPUPDATEITEMPROP)((LPBYTE)pUI + sizeof(UPDATEITEM)) ;
        for (c = 0 ; c < pUI->cProperties ; c++)
        {
            ar << "\tPropID/Offsets[" << c << "]\n" ;
            ar << _L(pUIP->dwPropertyID) ;
            ar << _H(pUIP->dwValueOffset) ;
            
            ar << "\t\tValues:\n" ;
            pvar = (VARIANT*)((LPBYTE)pUI + pUIP->dwValueOffset) ;

            ar << _PV(pvar) ;
            
            //ar << "\t" << _H(pvar->vt) ;
            //ar << "\t" << _H(pvar->wReserved1);
            //ar << "\t" << _H(pvar->wReserved2);
            //ar << "\t" << _H(pvar->wReserved3);
            //ar << "\t" << _D(pvar->iVal);
            //ar << "\t" << _D(pvar->lVal);
            //ar << "\t" << _D(pvar->fltVal);
            //ar << "\t" << _D(pvar->dblVal);
            //ar << "\t" << _D(pvar->bool);
            //ar << "\t" << _H(pvar->scode);            
            
            pUIP += 1 ;
        }        
        
        dwOffset = pUI->dwNext ;
    }
    
}

CString _strADDR( LPVOID p )
{
    static char sz[32] ;
    wsprintf( sz, "%#04lx:%#04lx", (DWORD)HIWORD((DWORD)p), (DWORD)LOWORD((DWORD)p) ) ;
    return sz ;
}
CString _strDWORD( DWORD d )
{
    static char sz[32] ;
    wsprintf( sz, "%#08lx", (DWORD)d ) ;
    return sz ;
}
CString _strLONG( LONG d )
{
    static char sz[32] ;
    wsprintf( sz, "%lu", (DWORD)d ) ;
    return sz ;
}

CString _strVARTYPE( VARTYPE vt )
{
    char* s = "<bad type>" ;
    switch(vt)
    {
        case VT_EMPTY: s = "VT_EMPTY" ; break ;    
        case VT_NULL: s = "VT_NULL" ; break ;      
        case VT_I2: s = "VT_I2" ; break ;        
        case VT_I4: s = "VT_I4" ; break ;        
        case VT_R4: s = "VT_R4" ; break ;        
        case VT_R8: s = "VT_R8" ; break ;        
        case VT_CY: s = "VT_CY" ; break ;        
        case VT_DATE: s = "VT_DATE" ; break ;      
        case VT_BSTR: s = "VT_BSTR" ; break ;      
        case VT_DISPATCH: s = "VT_DISPATCH" ; break ;  
        case VT_ERROR: s = "VT_ERROR" ; break ;     
        case VT_BOOL: s = "VT_BOOL" ; break ;      
        case VT_VARIANT: s = "VT_VARIANT" ; break ;   
        case VT_UNKNOWN: s = "VT_UNKNOWN" ; break ;   
    }    
    return s ;
}

CString _strVARIANT( VARIANT *pvar )
{
    CString s ;
    
    if (pvar->vt == VT_BSTR)
    {
        return (LPSTR)((LPSTR)pvar + sizeof(VARIANT)+sizeof(DWORD)) ;
    }
    
    VARIANT var ; VariantInit(&var) ;
    if (FAILED(VariantChangeType( &var, pvar, 0, VT_BSTR)))
        s = "Variant Converstion Error" ;
    else
    {
        s = var.bstrVal ;
        VariantClear( &var ) ;
    }    
    return s ; 
}

#endif 

