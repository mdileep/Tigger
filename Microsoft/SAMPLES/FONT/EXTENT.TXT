Knowledge Base Article:

  "Using GetCharABCWidths() to calculate text extents"

Keywords:

  GetCharABCWidths(), GetTextExtent(), TrueType, ABC Widths,
Fonts, GDI

Abstract:
  
  Windows Version 3.1 introduces a set of APIs for
  manipulating TrueType fonts.  The GetCharABCWidths()
  function can be used to accurately determine the advance
  width, overhang, and underhang of a character.
  Unfortunately there is a defect in Windows 3.10 where the
  ABC spacing is calculated incorrectly for fonts where
  embolding is simulated.  This article describes a work
  around for this problem, and in the process shows a
  useful technique for calculating the bounding rectangle
  for a string of text that works correctly regardless of
  font technology.

More information:
  
  ABC character spacing is generated by the TrueType
  rasterizer to allow applications to position characters
  exactly.  The "A" spacing is the distance that is added
  to the current position before placing the glyph. "B"
  spacing is the width of the black part of the glyph. "C"
  spacing is added to the current position to account for
  the white space to the right of the glyph. The total
  advanced width is given by A + B + C.  An application can
  use the advance width of a character to determine where
  to place the next character.
  
  The GetCharABCWidths() function retrieves the widths, in
  logical units, of consecutive characters in a specified
  range from the current TrueType font.  When the
  GetCharABCWidths() function retrieves negative "A" or "C"
  widths for a character, that character includes underhang
  or overhang, respectively.  The GetCharABCWidths()
  function works only for TrueType fonts.
  
  For non TrueType fonts the GetCharWidth() function can be
  used to determine advance width.  But because
  GetCharWidth() has no mechanism for determining negative
  "A" or "C" widths it cannot be used to exactly place
  text.
  
  In Windows 3.10 the GetCharABCWidths() function fails to
  work correctly when the selected font has embolding
  simulated.  (For example, there is no "WingDings Bold"
  TrueType font in Windows 3.1.  When a font created with
  the WingDings face name, and a weight greater than
  FW_NORMAL is selected into a DC.  The TrueType rasterizer
  simulates bold by manipulating the original non-bold
  outlines.)  The problem manifests itself when an
  application is trying to use GetCharABCWidths() to
  determine the advance width of simulated-bold TrueType
  font.  The ABC widths returned are off by one for each
  character.
  
  The work around to this bug is to add one to the B width
  of each character.  This raises the question "How does
  one detect that a font has embolding simulated?"
  
  The following function demonstrates how to determine if a
  TrueType font has embolding enabled.  This function
  should only be called with TrueType Fonts.
  
  BOOL NEAR PASCAL IsBoldSimulated( HDC hDC )
  {
     TEXTMETRIC                 tm ;
     OUTLINETEXTMETRIC          otm ;
  
     GetTextMetrics( hDC, &tm ) ;
  
     if (tm.tmWeight <= FW_NORMAL)
        return FALSE ;
  
     otm.otmSize = sizeof( OUTLINETEXTMETRIC ) ;
  
     /* Call GOTM() with the pointer to the buffer.  It
  will
      * fill in the buffer.
      */
     if (!GetOutlineTextMetrics( hDC, otm.otmSize, otm ))
        return FALSE ;  // bummer
  
     /* See the documentation on OUTLINETEXTMETRIC for a
      * description of the otmfsSelection member.
      */
     if (!(otm.otmfsSelection & 0x0020)) // bit 5 means
  bold
           return TRUE ;
  
  } /* IsBoldSimulated()  */
  
  It is very important to note that this bug only occurs in
  Windows 3.10 (GDI.EXE dated 3/10/92).  This bug will be
  fixed in all future versions, thus applications should
  take care to version bind the code that implements the
  work around.
  
  The following function demonstrates how to use
  GetCharABCWidths() to determine the bounding rectangle
  for a string of text.  It is very similar to the Windows
  APIs GetTextExtent() and GetTextExtentPoint() but
  correctly takes into account overhang and underhang
  caused by negative "A" and "C" widths.  This function
  also demonstrates how to correctly version bind the code
  that works around the previously mentioned bug in Windows
  3.10.
  
  /********************************************************
  *****
   *  UINT WINAPI GetTextExtentABCPoint( HDC hDC, LPSTR
  lpsz,
   *                                     int cb, LPSIZE
  lpSize )
   *
   *    Just like GetTextExtentPoint() but only works on TT
  fonts
   *    and uses GetCharABCWidths().
   *
   *    Unlike GetTextExtent() and GetTextExtentPoint()
  which
   *    return a BOOL, this function returns the absolute
  value
   *    for the "A" value of the first character if it is
   *    negative otherwise it returns 0.
   *
  
  *********************************************************
  *******/
  UINT WINAPI GetTextExtentABCPoint( HDC hDC, LPSTR lpsz,
                                     int cb, LPSIZE lpSize
  )
  {
     int          A, C ;
     UINT         nRet = 0 ;
     static LPABC lpABC ;
  
     GetTextExtentPoint( hDC, lpsz, cb, lpSize );
  
     if (lpABC ||
         (lpABC = (LPABC)GlobalAllocPtr( GHND,
  256*sizeof(ABC) )))
     {
        if (GetCharABCWidths( hDC, 0, 255, lpABC ))
        {
           int         n ;
  
           /* We now have an array of ABC structures
            */
           for ( lpSize->cx = 0, n = 0 ; n < cb ; n++ )
           {
              lpSize->cx += (
                             lpABC[(int)lpsz[n]].abcA +
                             lpABC[(int)lpsz[n]].abcB +
                             lpABC[(int)lpsz[n]].abcC ) ;
           }
  
           if( cb )
           {
              A = lpABC[(int)lpsz[0]].abcA;
  
              if( A < 0 )
              {
                 nRet = -A ;
                 lpSize->cx -= A;
              }
  
              C = lpABC[(int)lpsz[cb-1]].abcC ;
  
              if ( C < 0 )
                 lpSize->cx -= C ;    // two minus' make a
  plus
           }
  
           /* Bug in Windows 3.1.  If the tt font is
  embolded then
            * add one to the width for each char.
            */
           if ((BOOL)LOWORD( GetVersion() ) == 0x0A03 &&
               IsBoldSimulated( hDC ))
              lpSize->cx += cb ;
        }
        else
           GetTextExtentPoint( hDC, lpsz, cb, lpSize ) ;
  
        return nRet  ;
     }
     return nRet ;
  } /* GetTextExtentABCPoint()  */
  
